<?xml version="1.0"?><api><query><pages><page pageid="189842" ns="0" title="High-level programming language"><revisions><rev xml:space="preserve">{{Expert-subject|computer science|date=November 2008}}
A '''high-level programming language''' is a [[programming language]] with strong [[Abstraction (computer science)|abstraction]] from the details of the computer. In comparison to [[low-level programming language]]s, it may use [[natural language]] elements, be easier to use, or be from the specification of the program, making the process of developing a program simpler and more understandable with respect to a low-level language. The amount of abstraction provided defines how &quot;high-level&quot; a programming language is.&lt;ref&gt;[http://www.ittc.ku.edu/hybridthreads/glossary/index.php HThreads - RD Glossary&lt;!-- Bot generated title --&gt;]&lt;/ref&gt;

The first high-level programming language to be designed for a computer was [[PlankalkÃ¼l]], created by [[Konrad Zuse]]. However, it was not implemented in his time, and his original contributions were isolated from other developments.

== Features ==
&quot;High-level language&quot; refers to the higher level of abstraction from machine language. Rather than dealing with registers, memory addresses and call stacks, high-level languages deal with variables, arrays, [[Entity|objects]], complex arithmetic or boolean expressions, subroutines and functions, loops, [[Thread (computer science)|thread]]s, locks, and other abstract computer science concepts, with a focus on [[usability]] over optimal program efficiency. Unlike low-level [[assembly languages]], high-level languages have few, if any, language elements that translate directly into a machine's native [[opcodes]]. Other features, such as string handling routines, object-oriented language features, and file input/output, may also be present.

=== Abstraction penalty ===
Stereotypically, high-level languages make complex programming simpler, while low-level languages tend to produce more efficient code. ''Abstraction penalty'' is the barrier that prevents high-level programming techniques from being applied in situations where computational resources are limited. High-level programming features like more generic data structures, run-time interpretation, and intermediate code files often result in slower execution speed, higher memory consumption, and larger binary program size.&lt;ref&gt;{{cite paper
  | author = Surana P
  | title = Meta-Compilation of Language Abstractions.
  | year = 2006
  | url = ftp://lispnyc.org/meeting-assets/2007-02-13_pinku/SuranaThesis.pdf
  | format = [[PDF]]
  | accessdate = 2008-03-17 }}&lt;/ref&gt;&lt;ref&gt;{{cite web
  | last = Kuketayev 
  | title = The Data Abstraction Penalty (DAP) Benchmark for Small Objects in Java.
  | url= http://www.adtmag.com/joop/article.aspx?id=4597
  | accessdate = 2008-03-17 }}&lt;/ref&gt;&lt;ref&gt;{{Cite book
  | last = Chatzigeorgiou
  | last2 = Stephanides 
  | editor-last = Blieberger 
  | editor2-last = Strohmeier 
  | contribution = Evaluating Performance and Power Of Object-Oriented Vs. Procedural Programming Languages
  | title = Proceedings - 7th International Conference on Reliable Software Technologies - Ada-Europe'2002
  | year = 2002
  | pages = 367
  | publisher = Springer
  | postscript = &lt;!--None--&gt;
 }}&lt;/ref&gt; For this reason, code which needs to run particularly quickly and efficiently may require the use of a lower-level language, even if a higher-level language would make the coding easier. In many cases, [[Critical path|critical portions]] of a program mostly in a high-level language can be hand-coded in [[assembly language]], leading to a much faster or more efficient [[Program optimisation|optimised program]].

However, with the growing complexity of modern [[microprocessor]] architectures, well-designed compilers for high-level languages frequently produce code comparable in efficiency to what most low-level programmers can produce by hand,{{Citation needed|date=March 2008}} and the higher abstraction may allow for more powerful techniques providing better overall results than their low-level counterparts in particular settings.&lt;ref&gt;
{{Cite document
  | author = Manuel Carro, JosÃ© F. Morales, Henk L. Muller, G. Puebla, M. Hermenegildo 
  | title = Proceedings of the 2006 international conference on Compilers, architecture and synthesis for embedded systems
  | contribution  = High-level languages for small devices: a case study
  | url = http://www.clip.dia.fi.upm.es/papers/carro06:stream_interpreter_cases.pdf
  | format = [[PDF]]
  | year = 2006 
  | publisher = ACM
  | postscript = &lt;!--None--&gt;
}}&lt;/ref&gt;

== Relative meaning ==
The terms ''high-level'' and ''low-level'' are inherently relative. Some decades ago, the [[C (programming language)|C language]], and similar languages, were most often considered &quot;high-level&quot;, as it supported concepts such as expression evaluation, [[parameter]]ised recursive functions, and data types and structures, while [[assembly language]] was considered &quot;low-level&quot;.  Many programmers today might refer to C as low-level, as it lacks a large [[Run time system|runtime]]-system (no garbage collection, etc.), basically supports only scalar operations, and provides direct memory addressing. It, therefore, readily blends with assembly language and the machine level of [[CPU]]s and [[microcontroller]]s.

Assembly language may itself be regarded as a higher level (but often still one-to-one if used without [[Macro (computer science)|macro]]s) representation of [[machine code]], as it supports concepts such as constants and (limited) expressions, sometimes even variables, procedures, and [[data structure]]s. [[Machine code]], in its turn, is inherently at a slightly higher level than the [[microcode]] or [[micro-operation]]s used internally in many processors.

== Execution models ==
There are three models of execution for modern high-level languages:
; Interpreted : [[Interpreted language]]s are read and then executed directly, with no compilation stage. A program called an ''interpreter'' reads each program line following the program flow, converts it to machine code, and executes it; the machine code is then discarded, to be interpreted anew if the line is executed again.
; Compiled : [[Compiled language]]s are transformed into an executable form before running. There are two types of compilation:
:; Machine code generation : Some compilers compile source code directly into [[machine code]]. This is the original mode of compilation, and languages that are directly and completely transformed to machine-native code in this way may be called &quot;truly compiled&quot; languages.
:; Intermediate representations : When a language is compiled to an intermediate representation, that representation can be optimized or saved for later execution without the need to re-read the source file. When the intermediate representation is saved, it is often represented as [[byte code]]. The intermediate representation must then be interpreted or further compiled to execute it. [[Virtual machine]]s that execute byte code directly or transform it further into machine code have blurred the once clear distinction between intermediate representations and truly compiled languages.
; Translated : A language may be translated into a lower-level programming language for which native code compilers are already widely available. The [[C (programming language)|C programming language]] is a common target for such translators.

== See also ==
* [[Abstraction (computer science)]]
* [[Generational list of programming languages]]
* [[Low-level programming language]]s
* [[Very high-level programming language]]s
* [[Categorical list of programming languages]]

== References ==
{{Reflist}}

== External links ==
* http://c2.com/cgi/wiki?HighLevelLanguage - The [[WikiWikiWeb]]'s article on high-level programming languages

{{Programming language}}

{{DEFAULTSORT:High-Level Programming Language}}
[[Category:Programming language classification]]

[[ar:ÙØºØ© Ø¨Ø±ÙØ¬Ø© Ø¹Ø§ÙÙØ© Ø§ÙÙØ³ØªÙÙ]]
[[bn:à¦à¦à§à¦à¦¸à§à¦¤à¦°à§à¦° à¦ªà§à¦°à§à¦à§à¦°à¦¾à¦®à¦¿à¦ à¦­à¦¾à¦·à¦¾]]
[[ca:Llenguatge de programaciÃ³ d'alt nivell]]
[[cs:VyÅ¡Å¡Ã­ programovacÃ­ jazyk]]
[[de:HÃ¶here Programmiersprache]]
[[es:Lenguaje de alto nivel]]
[[fa:Ø²Ø¨Ø§Ù Ø¨Ø±ÙØ§ÙÙâÙÙÛØ³Û Ø³Ø·Ø­ Ø¨Ø§ÙØ§]]
[[fr:Langage de haut niveau]]
[[gl:Linguaxe de alto nivel]]
[[ko:ê³ ê¸ íë¡ê·¸ëë° ì¸ì´]]
[[hi:à¤à¤à¥à¤ à¤¸à¥à¤¤à¤°à¥à¤¯ à¤à¥à¤°à¤®à¤¾à¤¦à¥à¤¶à¤¨ à¤­à¤¾à¤·à¤¾]]
[[hr:Programski jezik visoke razine]]
[[id:Bahasa pemrograman tingkat tinggi]]
[[is:ÃÃ°ra forritunarmÃ¡l]]
[[it:Linguaggio di programmazione ad alto livello]]
[[he:×©×¤× ×¢××××ª]]
[[lv:Augsta lÄ«meÅa programmÄÅ¡anas valoda]]
[[hu:Magas szintÅ± programozÃ¡si nyelv]]
[[mk:Ð¡Ð»Ð¾Ð¶ÐµÐ½Ð¸ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼ÑÐºÐ¸ ÑÐ°Ð·Ð¸ÑÐ¸]]
[[ms:Bahasa pengaturcaraan aras tinggi]]
[[mn:ÐÑÑÐ´ ÑÒ¯Ð²ÑÐ½Ð¸Ð¹ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼ÑÐ»Ð°Ð»ÑÐ½ ÑÑÐ»]]
[[ja:é«æ°´æºè¨èª]]
[[no:HÃ¸ynivÃ¥sprÃ¥k]]
[[pl:JÄzyk wysokiego poziomu]]
[[pt:Linguagem de programaÃ§Ã£o de alto nÃ­vel]]
[[ru:ÐÑÑÐ¾ÐºÐ¾ÑÑÐ¾Ð²Ð½ÐµÐ²ÑÐ¹ ÑÐ·ÑÐº Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ]]
[[sl:Visokonivojski programski jezik]]
[[sh:Programski jezik visoke razine]]
[[sv:HÃ¶gnivÃ¥sprÃ¥k]]
[[zh:é«çº§è¯­è¨]]</rev></revisions></page></pages></query></api>
