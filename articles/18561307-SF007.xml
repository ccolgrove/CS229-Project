<?xml version="1.0"?><api><query><redirects><r from="Initrd.img" to="Initrd" /></redirects><pages><page pageid="3137188" ns="0" title="Initrd"><revisions><rev xml:space="preserve">{{lowercase|title=initrd}}
In computing, '''&lt;code&gt;initrd&lt;/code&gt;''' (''initial [[ramdisk]]'') is a scheme for loading a temporary [[file system]] into [[computer memory|memory]] in the boot process of the [[Linux kernel]]. &lt;code&gt;initrd&lt;code&gt; and &lt;code&gt;initramfs&lt;/code&gt; refer to slightly different methods of achieving this. Both are commonly used to make preparations before the real [[root directory|root]] file system can be [[mount (Unix)|mount]]ed.

== Rationale ==

Many [[Linux distribution]]s ship a single, generic kernel image that is intended to boot as wide a variety of hardware as possible.  The [[device driver]]s for this generic kernel image are included as [[loadable kernel module|loadable modules]], as it is not possible to statically compile them all into the one kernel without making it too large to boot from computers with limited memory or from lower-capacity media like floppy disks.&lt;ref name=&quot;almesberger2&quot;&gt;{{citation|last = Almesberger|first =  Werner|year = 2000|title = Booting linux: the history and the future|journal = Proceedings of the Ottawa Linux Symposium|url = http://www.linuxsymposium.org/2000/booting.php}}&lt;/ref&gt;{{Failed verification|date=August 2011}}

This then raises the problem of detecting and loading the modules necessary to mount the root file system at boot time (or, for that matter, deducing where or what the root file system is).&lt;ref name=&quot;almesberger2&quot; /&gt;

To further complicate matters, the root file system may be on a software [[RAID]] volume, [[Logical Volume Manager (Linux)|LVM]], [[Network File System (protocol)|NFS]] (on diskless workstations), or on an encrypted partition.  All of these require special preparations to mount.&lt;ref name=&quot;landley2&quot;&gt;{{citation|first = Rob|last = Landley|title = Introducing initramfs, a new model for initial RAM disks|date = 15 March 2005|url = http://linuxdevices.com/articles/AT4017834659.html|publisher = linuxdevices.com}}&lt;/ref&gt;

Another complication is kernel support for [[hibernate (OS feature)|hibernation]], which suspends the computer to disk by dumping an image of the entire contents of memory to a [[swap partition]] or a regular file, then powering off.  On next boot, this image has to be made accessible before it can be loaded back into memory.

To avoid having to hardcode handling for so many special cases into the kernel, an initial boot stage with a temporary root file systemânow dubbed [[early user space]]âis used.  This root file system would contain user-space helpers that would do the hardware detection, module loading and device discovery necessary to get the real root file system mounted.&lt;ref name=&quot;landley2&quot; /&gt;

== Implementation ==

An image of this initial root file system (along with the kernel image) must be stored somewhere accessible by the Linux [[bootloader]] or the boot firmware of the computer.  This can be:

* The root file system itself
* A [[El Torito (CD-ROM standard)|boot image]] on an [[optical disc]]
* A small [[ext3]] or [[File Allocation Table|FAT]]-formatted partition on a local disk (a ''boot partition'')
* A [[Trivial File Transfer Protocol|TFTP]] server (on systems that can boot from [[Ethernet]])

The bootloader will load the kernel and initial root file system image into memory and then start the kernel, passing in the memory address of the image. At the end of its boot sequence, the kernel tries to determine the format of the image from its first few blocks of data:
* In the '''initrd''' scheme, the image may be a file system image (optionally compressed), which is made available in a special [[block device]] (/dev/ram) that is then mounted as the initial root file system.&lt;ref name=&quot;almesberger&quot; /&gt; The driver for that file system must be compiled statically into the kernel.  Many distributions originally used compressed [[ext2]] file system images.  Others (including Debian 3.1) used [[cramfs]] in order to boot on memory-limited systems, since the cramfs image can be mounted in-place without requiring extra space for decompression.
: Once the initial root file system is up, the kernel executes &lt;tt&gt;/linuxrc&lt;/tt&gt; as its first process. When it exits, the kernel assumes that the real root file system has been mounted and executes &quot;/sbin/init&quot; to begin the normal user-space boot process.&lt;ref name=&quot;almesberger&quot;&gt;{{citation|url = http://www.kernel.org/doc/Documentation/initrd.txt|first1 = Werner|last1 = Almesberger|first2 = Hans|last2 = and Lermen|year = 2000}}&lt;/ref&gt;
* In the '''initramfs''' scheme (available in Linux 2.6.13 onwards), the image may be a [[cpio]] archive (optionally compressed).  The archive is unpacked by the kernel into a special instance of a [[tmpfs]] that becomes the initial root file system.  This scheme has the advantage of not requiring an intermediate file system or block drivers to be compiled into the kernel.&lt;ref name=&quot;landley&quot;&gt;{{citation|url = http://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt|title = ramfs, rootfs, and initramfs docs, take 2|first = Rob|last = Landley|publisher = Linux kernel source tree|date = 2005-10-17}}&lt;/ref&gt;
: On an initramfs, the kernel executes &lt;tt&gt;/init&lt;/tt&gt; as its first process. &lt;tt&gt;/init&lt;/tt&gt; is not expected to exit.

Depending on which algorithms were compiled statically into it, the kernel can currently unpack initrd/initramfs images compressed with [[gzip]], [[bzip2]], [[LZMA]] and [[Xz|XZ]].

=== Mount preparations ===

Some Linux distributions will generate a customized initrd image which contains only whatever is necessary to boot some particular computer, such as [[Advanced Technology Attachment|ATA]], [[SCSI]] and filesystem [[loadable kernel module|kernel modules]].  These typically embed the location and type of the root file system.

Other Linux distributions (such as [[Fedora (operating system)|Fedora]] and [[Ubuntu (operating system)|Ubuntu]]) generate a more generic initrd image.  These start only with the device name of the root file system (or its [[Universally unique identifier|UUID]]) and must discover everything else at boot time.  In this case, a complex cascade of tasks must be performed to get the root file system mounted:

* Any hardware drivers that the boot process depends on must be loaded.  A common arrangement is to pack kernel modules for common storage devices onto the initrd and then invoke a [[hotplug]] agent to pull in modules matching the computer's detected hardware.
* On systems which display a boot [[splash screen]], the video hardware must be initialized and a user-space helper started to paint animations onto the display in lockstep with the boot process.
* If the root file system is on NFS, it must then:
** Bring up the primary [[network card|network interface]].
** Invoke a [[Dynamic Host Configuration Protocol|DHCP]] client, with which it can obtain a DHCP lease.
** Extract the name of the NFS share and the address of the NFS server from the lease.
** Mount the NFS share.
* If the root file system appears to be on a software RAID device, there is no way of knowing which devices the RAID volume spans; the standard [[mdadm|MD utilities]] must be invoked to scan all available block devices and bring the required ones online.
* If the root file system appears to be on a [[logical volume]], the LVM utilities must be invoked to scan for and activate the [[volume group]] containing it.
* If the root file system is on an encrypted block device:
** Invoke a helper script to prompt the user to type in a passphrase and/or insert a hardware token (such as a [[smart card]] or a USB security [[dongle]]).
** Create a decryption target with the [[device mapper]].

Some distributions use an [[event-driven architecture|event-driven]] hotplug agent such as [[udev]], which invokes helper programs as hardware devices, disk partitions and storage volumes matching certain rules come online.  This allows discovery to run in parallel, and to progressively cascade into arbitrary nestings of LVM, RAID or encryption to get at the root file system.

When the root file system finally becomes visible:
* Any maintenance tasks which cannot run on a mounted root file system are done.
* The root file system is mounted read-only.
* Any processes which must continue running (such as the splash screen helper and its command [[named pipe|FIFO]]) are hoisted into the newly-mounted root file system.

The final root file system cannot simply be mounted over &lt;tt&gt;/&lt;/tt&gt;, since that would make the scripts and tools on the initial root file system inaccessible for any final cleanup tasks:
* On an initrd, the new root is mounted at a temporary mount point and rotated into place with [http://linux.die.net/man/8/pivot_root pivot_root(8)] (which was introduced specifically for this purpose).  This leaves the initial root file system at a mount point (such as &lt;tt&gt;/initrd&lt;/tt&gt;) where normal boot scripts can later unmount it to free up memory held by the initrd.
* On an initramfs, the initial root file system cannot be rotated away.&lt;ref&gt;{{citation|url = http://bugzilla.kernel.org/show_bug.cgi?id=4857|title = pivot_root from initramfs causes circular reference in mount tree|publisher = Linux Kernel Bug Tracker|date = 2005-07-06|accessdate = 2009-02-28|first = Richard|last = Fish}}&lt;/ref&gt; Instead, it is simply emptied and the final root file system mounted over the top.

Most initial root file systems implement &lt;tt&gt;/linuxrc&lt;/tt&gt; or &lt;tt&gt;/init&lt;/tt&gt; as a shell script and thus include a minimal shell (usually [[Almquist shell|/bin/ash]]) along with some essential user-space utilities (usually the [[BusyBox]] toolkit).  To further save space, the shell, utilities and their supporting libraries are typically compiled with space optimizations enabled (such as with [[GNU Compiler Collection|gcc]]'s &quot;-Os&quot; flag) and linked against [[klibc]], a minimal version of the [[C standard library|C library]] written specifically for this purpose.&lt;ref&gt;{{citation|url = http://lkml.org/lkml/2002/11/2/17|title = initramfs merge, part 1 of N|first = Jeff|last = Garzik|publisher = [[Linux kernel mailing list]]|date = 2002-11-02}}&lt;/ref&gt;

=== Other uses ===
Installers for Linux distributions are typically run entirely from an initramfs, as they must be able to host the installer interface and supporting tools before any persistent storage has been set up.

[[Tiny Core Linux]] also runs from initrd.&lt;ref&gt;http://distro.ibiblio.org/tinycorelinux/concepts.html&lt;/ref&gt;

[[Puppy Linux distros]] also runs from initrd.&lt;ref&gt;http://distro.ibiblio.org/puppylinux/puppy-5.3/release-Slacko-5.3.htm&lt;/ref&gt;

==See also==
* [[Linux startup process]]

== References ==
{{reflist}}

== External links ==
* [http://wiki.debian.org/InitrdReplacementOptions Detailed comparison] of initrd-generating toolkits
* [http://lxr.linux.no/source/Documentation/early-userspace/ Kernel documentation] on early userspace support
* [http://www.microsuncn.com/index.php?title=Analysis_linux_initrd Analysis linux initrd]
{{Use dmy dates|date=August 2011}}

[[Category:Linux kernel]]

[[de:Initrd]]
[[es:Initrd]]
[[fr:Initrd]]
[[it:Initrd]]
[[ja:Initrd]]
[[pl:Initrd]]
[[ru:Initrd]]
[[sv:Initrd]]
[[uk:Initrd]]
[[zh:Initrd]]</rev></revisions></page></pages></query></api>
