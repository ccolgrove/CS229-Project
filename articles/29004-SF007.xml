<?xml version="1.0"?><api><query><pages><page pageid="29004" ns="0" title="SQL"><revisions><rev xml:space="preserve">{{About|the database language|the airport with IATA code SQL|San Carlos Airport}}
{{Infobox programming language
| name                   = SQL
| paradigm               = [[Multi-paradigm programming language|Multi-paradigm]]
| year                   = 1974
| designer               = [[Donald D. Chamberlin]]&lt;br /&gt;[[Raymond F. Boyce]]
| developer              = [[ISO]]/[[IEC]]
| latest_release_version = SQL:2008
| latest_release_date    = 2008
| turing-complete        = No
| typing                 = [[Static typing|Static]], [[strong typing|strong]]
| implementations        = [[List of relational database management systems|Many]]
| dialects               = SQL-86, SQL-89, [[SQL-92]], [[SQL:1999]], [[SQL:2003]], [[SQL:2008]]
| influenced_by          = [[Datalog]]
| influenced             = [[Agena (programming language)|Agena]], [[Common Query Language|CQL]], [[Language Integrated Query|LINQ]], [[Windows PowerShell]]&lt;ref name=ars&gt;{{cite web|last=Paul|first=Ryan|title=A guided tour of the Microsoft Command Shell|url=http://arstechnica.com/business/news/2005/10/msh.ars/4|publisher=Ars Technica|accessdate=10 April 2011}}&lt;/ref&gt;
| operating_system       = [[Cross-platform]]
| website                = {{cite web | url = http://www.iso.org/iso/catalogue_detail.htm?csnumber=45498 | title = ISO/IEC 9075-1:2008: Information technology â Database languages â SQL â Part 1: Framework (SQL/Framework) | postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}}}
| file_ext               = .sql
}}
{{Infobox file format
| name                   = SQL
| screenshot             =
| caption                = Structured Query Language
| extension              = .sql
| mime                   = application/x-sql
| uniform type           =
| owner                  = [[ISO]]/[[IEC]]
| released               = {{Start date|1986|df=yes}}
| latest release version = SQL:2008
| latest release date    = {{Start date and age|2008|df=yes}}
| genre                  = Database
| standard               = ISO/IEC 9075
| free                   = Yes
| url                    = &lt;ref name=&quot;Ars Technica&quot;&gt;{{cite web | url = http://www.iso.org/iso/catalogue_detail.htm?csnumber=45498 | title = ISO/IEC 9075-1:2008: Information technology â Database languages â SQL â Part 1: Framework (SQL/Framework) | postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}}}&lt;/ref&gt;
}}

'''SQL''' (officially {{IPAc-en|icon|Ë|É|s|_|k|juË|_|Ë|É|l}}, often {{IPAc-en|icon|Ë|s|iË|k|w|Él}};&lt;ref&gt;{{cite book |last= Beaulieu | first = Alan |title=Learning SQL |editor=Mary E Treseler |publisher=O'Reilly |location=Sebastapol, CA, USA |date=April 2009 |edition= 2nd | isbn = 978-0-596-52083-0}}&lt;/ref&gt; often referred to as '''Structured Query Language''') is a [[programming language]] designed for managing data in [[relational database management system]]s (RDBMS).

Originally based upon [[relational algebra]] and [[tuple relational calculus]],&lt;ref name = &quot;Darwen&quot;&gt;{{Cite book| first = Hugh | last = Darwen | authorlink = Hugh Darwen | editor-first = Fabian | editor-last = Pascal | title = Database Debunkings | url = http://www.dbdebunk.com/page/page/1897740.htm | contribution = More on Relational Algebra versus Calculus | date = 2005-04-15| unused_data = É|s|_|k| postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}} }}&lt;/ref&gt; its scope includes data insert, query, [[Data Manipulation Language|update and delete]], [[database schema|schema]] creation and modification, and data access control.

SQL was one of the first commercial languages for [[Edgar F. Codd]]'s [[relational model]], as described in his influential 1970 paper, &quot;A Relational Model of Data for Large Shared Data Banks&quot;.&lt;ref name=&quot;codd-relational-model&quot;&gt;{{cite journal | last = Codd | first = Edgar F | title = A Relational Model of Data for Large Shared Data Banks | journal = Communications of the ACM | volume = 13 | issue = 6 | pages = 377â87 | publisher = Association for Computing Machinery | month = June | year = 1970 | url = http://www.acm.org/classics/nov95/toc.html | accessdate = 2007-06-09 | doi = 10.1145/362384.362685}}&lt;/ref&gt;  Despite not adhering to [[Codd's 12 rules|the relational model as described by Codd]], it became the most widely used database language.&lt;ref name=&quot;SQL-Fundamentals&quot; /&gt;&lt;ref name=&quot;IBM-sql&quot;&gt;{{cite web | title = Structured Query Language (SQL) | publisher = International Business Machines | url = http://publib.boulder.ibm.com/infocenter/db2luw/v9/index.jsp?topic=com.ibm.db2.udb.admin.doc/doc/c0004100.htm | date = October 27, 2006 | accessdate = 2007-06-10 }}&lt;/ref&gt; Though often described as, and to a great extent is a [[Declarative programming|declarative language]], SQL also includes [[Procedural programming|procedural]] elements. SQL became a [[Technical standard|standard]] of the [[American National Standards Institute]] (ANSI) in 1986, and of the [[International Organization for Standards]] (ISO) in 1987. Since then the standard has been enhanced several times with added features. However, issues of SQL code portability between major RDBMS products still exist due to lack of full compliance with, or different interpretations of the standard. Among the reasons mentioned are the large size, and incomplete specification of the standard, as well as [[vendor lock-in]].

==History==
SQL was initially developed at [[IBM]] by [[Donald D. Chamberlin]] and [[Raymond F. Boyce]] in the early 1970s. This version, initially called '''SEQUEL''' (''Structured English Query Language''), was designed to manipulate and retrieve data stored in IBM's original quasi-relational database management system, [[IBM System R|System R]], which a group at [[IBM Almaden Research Center|IBM San Jose Research Laboratory]] had developed during the 1970s.&lt;ref name=&quot;chamberlin-boyce-sequel&quot;&gt;{{cite journal
 | last = Chamberlin
 | first = Donald D
 | coauthors = Boyce, Raymond F
 | title = SEQUEL: A Structured English Query Language
 | journal = Proceedings of the 1974 ACM SIGFIDET Workshop on Data Description, Access and Control
 | pages = 249â64
 | publisher = Association for Computing Machinery
 | year = 1974
 | format= PDF
 | url = http://www.almaden.ibm.com/cs/people/chamberlin/sequel-1974.pdf
 | accessdate = 2007-06-09 }}&lt;/ref&gt; The acronym SEQUEL was later changed to SQL because &quot;SEQUEL&quot; was a [[trademark]] of the [[United Kingdom|UK-based]] [[Hawker Siddeley]] aircraft company.&lt;ref name=&quot;oppel-databases&quot;&gt;{{cite book
 | last = Oppel
 | first = Andy
 | title = Databases Demystified
 | publisher = McGraw-Hill Osborne Media
 | date = February 27, 2004
 | location = [[San Francisco, CA]]
 | pages = 90â1
 | url = http://www.mhprofessional.com/product.php?cat=112&amp;isbn=0071469605
 | isbn = 0-07-146960-5 }}&lt;/ref&gt;

The first ''Relational Database Management System'' (RDBMS) was [[Relational database management system|RDMS]], developed at [[MIT]] in the early 1970s, soon followed by [[Ingres (database)|Ingres]], developed in 1974 at [[University of California, Berkeley|U.C. Berkeley]]. Ingres implemented a query language known as [[QUEL query languages|QUEL]], which was later supplanted in the marketplace by SQL.&lt;ref name=&quot;oppel-databases&quot;/&gt;

In the late 1970s, Relational Software, Inc. (now [[Oracle Corporation]]) saw the potential of the concepts described by Codd, Chamberlin, and Boyce and developed their own SQL-based [[RDBMS]] with aspirations of selling it to the [[United States Navy|U.S. Navy]], [[Central Intelligence Agency]], and other [[Federal government of the United States|U.S. government]] agencies. In June 1979, Relational Software, Inc. introduced the first commercially available implementation of SQL, [[Oracle database|Oracle]] V2 (Version2) for [[VAX]] computers. ''Oracle V2'' beat IBM's August release of the [[System/38]] RDBMS to market by a few weeks.{{Citation needed|date=June 2007}}

After testing SQL at customer test sites to determine the usefulness and practicality of the system, IBM began developing commercial products based on their System R prototype including System/38, [[SQL/DS]], and [[IBM DB2|DB2]], which were commercially available in 1979, 1981, and 1983, respectively.&lt;ref name=&quot;IBM-history&quot;&gt;{{cite web
 | title = History of IBM, 1978
 | work = IBM Archives
 | publisher = IBM
 | url = http://www-03.ibm.com/ibm/history/history/year_1978.html
 | accessdate = 2007-06-09 }}&lt;/ref&gt;


[[File:SQL ANATOMY wiki.svg|thumb|275px|This chart shows several of the SQL language elements that compose a single statement.]]

The SQL language is sub-divided into several language elements, including:
* '''Clauses''', which are constituent components of statements and queries. (In some cases, these are optional.)&lt;ref&gt;ANSI/ISO/IEC International Standard (IS). Database Language SQLâPart 2: Foundation (SQL/Foundation). 1999.&lt;/ref&gt;
* '''Expressions''', which can produce either [[scalar (computing)|scalar]] values or [[table (database)|tables]] consisting of [[column (database)|columns]] and [[row (database)|rows]] of data.
* '''Predicates''', which specify conditions that can be evaluated to SQL [[ternary logic|three-valued logic (3VL)]] or [[Boolean logic|Boolean]] (true/false/unknown) [[truth value]]s and which are used to limit the effects of statements and queries, or to change program flow.
* '''Queries''', which retrieve the data based on specific criteria. This is the most important element of '''SQL'''.
* '''Statements''', which may have a persistent effect on schemata and data, or which may control transactions, program flow, connections, sessions, or diagnostics.
** SQL statements also include the [[semicolon]] (&quot;;&quot;) statement terminator. Though not required on every platform, it is defined as a standard part of the SQL grammar.
* '''[[Whitespace (computer science)|Insignificant whitespace]]''' is generally ignored in SQL statements and queries, making it easier to format SQL code for readability.

===Queries===
The most common operation in SQL is the query, which is performed with the declarative &lt;code&gt;[[Select (SQL)|SELECT]]&lt;/code&gt; statement. &lt;code&gt;SELECT&lt;/code&gt; retrieves data from one or more [[Table (database)|table]]s, or expressions. Standard &lt;code&gt;SELECT&lt;/code&gt; statements have no persistent effects on the database. Some non-standard implementations of &lt;code&gt;SELECT&lt;/code&gt; can have persistent effects, such as the &lt;code&gt;SELECT INTO&lt;/code&gt; syntax that exists in some databases.&lt;ref name=&quot;ms-sql-select-into&quot;&gt;{{Cite book
 |                                                        chapter = Transact-SQL Reference
| contribution = INTO Clause (Transact-SQL)
| title = SQL Server Language Reference
 | series = SQL Server 2005 Books Online
 | publisher = Microsoft
 | date = 2007-09-15
 | url = http://msdn2.microsoft.com/en-us/library/ms188029(SQL.90).aspx
 | accessdate = 2007-06-17
 |                                                        postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}}}&lt;/ref&gt;

Queries allow the user to describe desired data, leaving the [[Database management system|database management system (DBMS)]] responsible for [[query plan|planning]], [[query optimizer|optimizing]], and performing the physical operations necessary to produce that result as it chooses.

A query includes a list of columns to be included in the final result immediately following the &lt;code&gt;SELECT&lt;/code&gt; keyword. An asterisk (&quot;&lt;code&gt;*&lt;/code&gt;&quot;) can also be used to specify that the query should return all columns of the queried tables. &lt;code&gt;SELECT&lt;/code&gt; is the most complex statement in SQL, with optional keywords and clauses that include:
* The &lt;code&gt;[[From (SQL)|FROM]]&lt;/code&gt; clause which indicates the table(s) from which data is to be retrieved.  The &lt;code&gt;FROM&lt;/code&gt; clause can include optional &lt;code&gt;[[Join (SQL)|JOIN]]&lt;/code&gt; subclauses to specify the rules for joining tables.
* The &lt;code&gt;[[Where (SQL)|WHERE]]&lt;/code&gt; clause includes a comparison predicate, which restricts the rows returned by the query. The &lt;code&gt;WHERE&lt;/code&gt; clause eliminates all rows from the result set for which the comparison predicate does not evaluate to True.
* The &lt;code&gt;GROUP BY&lt;/code&gt; clause is used to project rows having common values into a smaller set of rows. &lt;code&gt;GROUP BY&lt;/code&gt; is often used in conjunction with SQL aggregation functions or to eliminate duplicate rows from a result set. The &lt;code&gt;WHERE&lt;/code&gt; clause is applied before the &lt;code&gt;GROUP BY&lt;/code&gt; clause.
* The &lt;code&gt;[[Having (SQL)|HAVING]]&lt;/code&gt; clause includes a predicate used to filter rows resulting from the &lt;code&gt;GROUP BY&lt;/code&gt; clause. Because it acts on the results of the &lt;code&gt;GROUP BY&lt;/code&gt; clause, aggregation functions can be used in the &lt;code&gt;HAVING&lt;/code&gt; clause predicate.
* The &lt;code&gt;[[Order by (SQL)|ORDER BY]]&lt;/code&gt; clause identifies which columns are used to sort the resulting data, and in which direction they should be sorted (options are ascending or descending). Without an &lt;code&gt;ORDER BY&lt;/code&gt; clause, the order of rows returned by an SQL query is undefined.

The following is an example of a &lt;code&gt;SELECT&lt;/code&gt; query that returns a list of expensive books. The query retrieves all rows from the ''Book'' table in which the ''price'' column contains a value greater than 100.00. The result is sorted in ascending order by ''title''. The asterisk (*) in the ''select list'' indicates that all columns of the ''Book'' table should be included in the result set.
&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
SELECT *
    FROM Book
    WHERE price &gt; 100.00
    ORDER BY title;
&lt;/syntaxhighlight&gt;

The example below demonstrates a query of multiple tables, grouping, and aggregation, by returning a list of books and the number of authors associated with each book.

&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
SELECT Book.title,
        count(*) AS Authors
    FROM  Book JOIN Book_author
       ON Book.isbn = Book_author.isbn
    GROUP BY Book.title;
&lt;/syntaxhighlight&gt;

Example output might resemble the following:

 Title                   Authors
 ----------------------  -------
 SQL Examples and Guide     4
 The Joy of SQL             1
 An Introduction to SQL     2
 Pitfalls of SQL            1

Under the precondition that ''isbn'' is the only common column name of the two tables and that a column named ''title'' only exists in the ''Books'' table, the above query could be rewritten in the following form:

&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
SELECT title,
        count(*) AS Authors
    FROM  Book NATURAL JOIN Book_author
    GROUP BY title;
&lt;/syntaxhighlight&gt;

However, many vendors either do not support this approach, or require certain column naming conventions in order for natural joins to work effectively.

SQL includes operators and functions for calculating values on stored values. SQL allows the use of expressions in the ''select list'' to project data, as in the following example which returns a list of books that cost more than 100.00 with an additional ''sales_tax'' column containing a sales tax figure calculated at 6% of the ''price''.

&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
SELECT isbn,
        title,
        price,
        price * 0.06 AS sales_tax
    FROM Book
    WHERE price &gt; 100.00
    ORDER BY title;
&lt;/syntaxhighlight&gt;

====Null and three-valued logic (3VL)====
The idea of [[Null (SQL)|Null]] was introduced into SQL to handle missing information in the relational model. The introduction of Null (or Unknown) along with True and False is the foundation of [[three-valued logic]]. Null does not have a value (and is not a member of any data domain) but is rather a placeholder or &quot;mark&quot; for missing information. Therefore comparisons with Null can never result in either True or False but always in the third logical result.&lt;ref name=&quot;SQL2003-Part2-Sec87&quot;&gt;{{cite book
 | last =ISO/IEC
 | title =ISO/IEC 9075-2:2003, &quot;SQL/Foundation&quot;
 | publisher =ISO/IEC
 | nopp =true
}}&lt;/ref&gt;

SQL uses Null to handle missing information. It supports three-valued logic (3VL) and the rules governing SQL three-valued logic are shown below (p and q represent logical states).&lt;ref name=&quot;fourrules&quot;&gt;{{cite journal |last = Coles, Michael |title = Four Rules for Nulls |journal = SQL Server Central |publisher = Red Gate Software |date = 2005-06-27 |url = http://www.sqlservercentral.com/columnists/mcoles/fourrulesfornulls.asp }}&lt;/ref&gt; The word NULL is also a reserved keyword in SQL, used to identify the Null special marker.

Additionally, since SQL operators return Unknown when comparing anything with Null, SQL provides two Null-specific comparison predicates: &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt; test whether data is or is not Null.&lt;ref name=&quot;SQL2003-Part2-Sec87&quot;/&gt;

Note that SQL returns only results for which the WHERE clause returns a value of True; i.e. it excludes results with values of False and also excludes those whose value is Unknown.
{| border=&quot;0&quot;
|-
| valign=&quot;top&quot; |
{| class=&quot;wikitable&quot;
|-
! colspan=&quot;2&quot; rowspan=&quot;2&quot; | p AND q
! colspan=&quot;3&quot; | p
|-
! True
! False
! Unknown
|-
! rowspan=&quot;3&quot; | q || True
| True
| False
| Unknown
|-
! False
| False
| False
| False
|-
! Unknown
| Unknown
| False
| Unknown
|}
| valign=&quot;top&quot; |
{| class=&quot;wikitable&quot;
|-
! colspan=&quot;2&quot; rowspan=&quot;2&quot; | p OR q
! colspan=&quot;3&quot; | p
|-
! True
! False
! Unknown
|-
! rowspan=&quot;3&quot; | q || True
| True
| True
| True
|-
! False
| True
| False
| Unknown
|-
! Unknown
| True
| Unknown
| Unknown
|}
|}

{| border=&quot;0&quot;
|-
| valign=&quot;top&quot; |
{| class=&quot;wikitable&quot;
|-
! p
! NOT p
|-
| True
| False
|-
| False
| True
|-
| Unknown
| Unknown
|}
| valign=&quot;top&quot; |
{| class=&quot;wikitable&quot;
|-
! colspan=&quot;2&quot; rowspan=&quot;2&quot; | p = q
! colspan=&quot;3&quot; | p
|-
! True
! False
! Unknown
|-
! rowspan=&quot;3&quot; | q || True
| True
| False
| Unknown
|-
! False
| False
| True
| Unknown
|-
! Unknown
| Unknown
| Unknown
| Unknown
|}
|}

[[Universal quantification]] is not explicitly supported by SQL, and must be worked out as a negated [[existential quantification]].&lt;ref&gt;M. Negri, G. Pelagatti, L. Sbattella (1989) ''[http://portal.acm.org/citation.cfm?id=63224.68822&amp;coll=GUIDE&amp;dl=GUIDE Semantics and problems of universal quantification in SQL]''.&lt;/ref&gt;&lt;ref&gt;Fratarcangeli, Claudio (1991). ''Technique for universal quantification in SQL''. Retrieved from [http://portal.acm.org/citation.cfm?id=126482.126484&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=5934371&amp;CFTOKEN=55309005 ACM.org.]&lt;/ref&gt;&lt;ref name=&quot;kawash&quot;&gt;Kawash, Jalal (2004). ''Complex quantification in Structured Query Language (SQL): a tutorial using relational calculus'' - Journal of Computers in Mathematics and Science Teaching ISSN 0731-9258 Volume 23, Issue 2, 2004 AACE Norfolk, Virginia. Retrieved from [http://www.thefreelibrary.com/Complex+quantification+in+Structured+Query+Language+(SQL):+a+tutorial...-a0119901477 Thefreelibrary.com].&lt;/ref&gt;

There is also the &quot;&lt;row value expression&gt; IS DISTINCT FROM &lt;row value expression&gt;&quot; infixed comparison operator which returns TRUE unless both operands are equal or both are NULL. Likewise, IS NOT DISTINCT FROM is defined as &quot;NOT (&lt;row value expression&gt; IS DISTINCT FROM &lt;row value expression&gt;)&quot;.

===Data manipulation===

The [[Data Manipulation Language]] (DML) is the subset of SQL used to add, update and delete data:
* &lt;code&gt;[[Insert (SQL)|INSERT]]&lt;/code&gt; adds rows (formally [[tuple]]s) to an existing table, e.g.,:
&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
INSERT INTO My_table
        (field1, field2, field3)
    VALUES
        ('test', 'N', NULL);
&lt;/syntaxhighlight&gt;
* &lt;code&gt;[[Update (SQL)|UPDATE]]&lt;/code&gt; modifies a set of existing table rows, e.g.,:
&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
UPDATE My_table
    SET field1 = 'updated value'
    WHERE field2 = 'N';
&lt;/syntaxhighlight&gt;
* &lt;code&gt;[[Delete (SQL)|DELETE]]&lt;/code&gt; removes existing rows from a table, e.g.,:
&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
DELETE FROM My_table
    WHERE field2 = 'N';
&lt;/syntaxhighlight&gt;
* &lt;code&gt;[[Merge (SQL)|MERGE]]&lt;/code&gt; is used to combine the data of multiple tables. It combines the &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; elements. It is defined in the SQL:2003 standard; prior to that, some databases provided similar functionality via different syntax, sometimes called &quot;[[upsert]]&quot;.

===Transaction controls===

Transactions, if available, wrap DML operations:

* &lt;code&gt;START TRANSACTION&lt;/code&gt; (or &lt;code&gt;BEGIN WORK&lt;/code&gt;, or &lt;code&gt;BEGIN TRANSACTION&lt;/code&gt;, depending on SQL dialect) mark the start of a [[database transaction]], which either completes entirely or not at all.
* &lt;code&gt;SAVE TRANSACTION&lt;/code&gt; (or &lt;code&gt;SAVEPOINT&lt;/code&gt; ) save the state of the database at the current point in transaction
&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
CREATE TABLE tbl_1(id int);
  INSERT INTO tbl_1(id) VALUES(1);
  INSERT INTO tbl_1(id) VALUES(2);
COMMIT;
  UPDATE tbl_1 SET id=200 WHERE id=1;
SAVEPOINT id_1upd;
  UPDATE tbl_1 SET id=1000 WHERE id=2;
ROLLBACK to id_1upd;
  SELECT id from tbl_1;
&lt;/syntaxhighlight&gt;
* &lt;code&gt;[[Commit (SQL)|COMMIT]]&lt;/code&gt; causes all data changes in a transaction to be made permanent.
* &lt;code&gt;[[Rollback (SQL)|ROLLBACK]]&lt;/code&gt; causes all data changes since the last &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;ROLLBACK&lt;/code&gt; to be discarded, leaving the state of the data as it was prior to those changes.

Once the &lt;code&gt;COMMIT&lt;/code&gt; statement completes, the transaction's changes cannot be rolled back.

&lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt; terminate the current transaction and release data locks. In the absence of a &lt;code&gt;START TRANSACTION&lt;/code&gt; or similar statement, the semantics of SQL are implementation-dependent.
Example: ''A classic bank transfer of funds transaction.''

&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
START TRANSACTION;
  UPDATE Account SET amount=amount-200 WHERE account_number=1234;
  UPDATE Account SET amount=amount+200 WHERE account_number=2345;

IF ERRORS=0 COMMIT;
IF ERRORS&lt;&gt;0 ROLLBACK;
&lt;/syntaxhighlight&gt;

===Data definition===

The [[Data Definition Language]] (DDL) manages table and index structure. The most basic items of DDL are the &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;ALTER&lt;/code&gt;, &lt;code&gt;RENAME&lt;/code&gt;, &lt;code&gt;DROP&lt;/code&gt; and &lt;code&gt;TRUNCATE&lt;/code&gt; statements:

* &lt;code&gt;[[Create (SQL)|CREATE]]&lt;/code&gt; creates an object (a table, for example) in the database, e.g.,:
&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
CREATE TABLE My_table(
    my_field1   INT,
    my_field2   VARCHAR(50),
    my_field3   DATE         NOT NULL,
    PRIMARY KEY (my_field1, my_field2)
);
&lt;/syntaxhighlight&gt;
* &lt;code&gt;[[Alter (SQL)|ALTER]]&lt;/code&gt; modifies the structure of an existing object in various ways, for example, adding a column to an existing table or a constraint, e.g.,:
&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
ALTER TABLE My_table ADD my_field4 NUMBER(3) NOT NULL;
&lt;/syntaxhighlight&gt;
* &lt;code&gt;[[Truncate (SQL)|TRUNCATE]]&lt;/code&gt; deletes all data from a table in a very fast way, deleting the data inside the table and not the table itself. It usually implies a subsequent COMMIT operation, i.e., it cannot be rolled back.
&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
TRUNCATE TABLE My_table;
&lt;/syntaxhighlight&gt;
* &lt;code&gt;[[Drop (SQL)|DROP]]&lt;/code&gt; deletes an object in the database, usually irretrievably, i.e., it cannot be rolled back, e.g.,:
&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
DROP TABLE My_table;
&lt;/syntaxhighlight&gt;

===Data types===
Each column in an SQL table declares the type(s) that column may contain. ANSI SQL includes the following data types.&lt;ref name=&quot;SQL1992&quot;&gt;{{Cite document | url = http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt | title = Information Technology â Database Language SQL | publisher = CMU | postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}}} (proposed revised text of DIS 9075)].&lt;/ref&gt;

====Character strings====
* &lt;code&gt;CHARACTER(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;CHAR(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; &amp;mdash; fixed-width &lt;var&gt;n&lt;/var&gt;-character string, padded with spaces as needed
* &lt;code&gt;CHARACTER VARYING(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;VARCHAR(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; &amp;mdash; variable-width string with a maximum size of &lt;var&gt;n&lt;/var&gt; characters
* &lt;code&gt;NATIONAL CHARACTER(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;NCHAR(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; &amp;mdash; fixed width string supporting an international character set
* &lt;code&gt;NATIONAL CHARACTER VARYING(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;NVARCHAR(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; &amp;mdash; variable-width &lt;code&gt;NCHAR&lt;/code&gt; string

====Bit strings====
* &lt;code&gt;BIT(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; &amp;mdash; an array of &lt;var&gt;n&lt;/var&gt; bits
* &lt;code&gt;BIT VARYING(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; &amp;mdash; an array of up to &lt;var&gt;n&lt;/var&gt; bits

====Numbers====
* &lt;code&gt;INTEGER&lt;/code&gt; and &lt;code&gt;SMALLINT&lt;/code&gt;
* &lt;code&gt;FLOAT&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt; and &lt;code&gt;DOUBLE PRECISION&lt;/code&gt;
* &lt;code&gt;NUMERIC(&lt;var&gt;precision&lt;/var&gt;, &lt;var&gt;scale&lt;/var&gt;)&lt;/code&gt; or &lt;code&gt;DECIMAL(&lt;var&gt;precision&lt;/var&gt;, &lt;var&gt;scale&lt;/var&gt;)&lt;/code&gt;

The &lt;var&gt;precision&lt;/var&gt; is a positive integer that determines the number of significant digits in a particular radix (binary or decimal). The &lt;var&gt;scale&lt;/var&gt; is a non-negative integer. A scale of 0 indicates that the number is an integer. For a scale of S, the exact numeric value is the integer value of the significant digits multiplied by 10-S.

SQL provides a function to round numerics or dates, called &lt;code&gt;TRUNC&lt;/code&gt; (in Informix, DB2, PostgreSQL, Oracle and MySQL) or &lt;code&gt;ROUND&lt;/code&gt; (in Informix, Sybase, Oracle, PostgreSQL and Microsoft SQL Server)&lt;ref name=&quot;Jones 127&quot;&gt;Arie Jones, Ryan K. Stephens, Ronald R. Plew, Alex Kriegel, Robert F. Garrett (2005), ''SQL Functions Programmer's Reference''. Wiley, 127 pages.&lt;/ref&gt;

====Date and time====
* &lt;code&gt;DATE&lt;/code&gt; &amp;mdash; for date values (e.g., &lt;code&gt;2011-05-03&lt;/code&gt;)
* &lt;code&gt;TIME&lt;/code&gt; â for time values (e.g., &lt;code&gt;15:51:36&lt;/code&gt;). The granularity of the time value is usually a ''tick'' (100 nanoseconds).
* &lt;code&gt;TIME WITH TIME ZONE&lt;/code&gt; or &lt;code&gt;TIMETZ&lt;/code&gt;&amp;nbsp;â the same as &lt;code&gt;TIME&lt;/code&gt;, but including details about the time zone in question.
* &lt;code&gt;TIMESTAMP&lt;/code&gt; &amp;mdash; This is a &lt;code&gt;DATE&lt;/code&gt; and a &lt;code&gt;TIME&lt;/code&gt; put together in one variable (e.g., &lt;code&gt;2011-05-03 15:51:36&lt;/code&gt;).
* &lt;code&gt;TIMESTAMP WITH TIME ZONE&lt;/code&gt; or &lt;code&gt;TIMESTAMPTZ&lt;/code&gt; â the same as &lt;code&gt;TIMESTAMP&lt;/code&gt;, but including details about the time zone in question.

SQL provides several functions for generating a date / time variable out of a date / time string (&lt;code&gt;TO_DATE&lt;/code&gt;, &lt;code&gt;TO_TIME&lt;/code&gt;, &lt;code&gt;TO_TIMESTAMP&lt;/code&gt;), as well as for extracting the respective members (seconds, for instance) of such variables.  The current system date / time of the database server can be called by using functions like &lt;code&gt;NOW&lt;/code&gt;.

===Data control===

The [[Data Control Language]] (DCL) authorizes users and groups of users to access and manipulate data.
Its two main statements are:

* &lt;code&gt;GRANT&lt;/code&gt; authorizes one or more users to perform an operation or a set of operations on an object.
* &lt;code&gt;REVOKE&lt;/code&gt; eliminates a grant, which may be the default grant.

Example:
&lt;syntaxhighlight lang=&quot;sql&quot;&gt;
GRANT SELECT, UPDATE
    ON My_table
    TO some_user, another_user;

REVOKE SELECT, UPDATE
    ON My_table
    FROM some_user, another_user;
&lt;/syntaxhighlight&gt;

===Procedural extensions===

SQL is designed for a specific purpose: to query [[data]] contained in a [[relational database]]. SQL is a [[Set (computer science)|set]]-based, [[Declarative programming|declarative]] query language, not an [[Imperative programming|imperative language]] such as [[C (programming language)|C]] or [[BASIC programming language|BASIC]]. However, there are extensions to Standard SQL which add [[procedural programming language]] functionality, such as control-of-flow constructs. These include:

{| class=&quot;wikitable&quot;
|-
! Source
! Common&lt;br&gt;Name
! Full Name
|-
| style=&quot;text-align:center;&quot;| ANSI/ISO Standard
| style=&quot;text-align:center;&quot;| [[SQL/PSM]]
| SQL/Persistent Stored Modules
|-
| style=&quot;text-align:center;&quot;| [[Interbase]]/&lt;br&gt;[[Firebird (database server)|Firebird]]
| style=&quot;text-align:center;&quot;| [[PSQL]]
| Procedural SQL
|-
| style=&quot;text-align:center;&quot;| IBM
| style=&quot;text-align:center;&quot;| [[SQL PL]]
| SQL Procedural Language (implements SQL/PSM)
|-
| style=&quot;text-align:center;&quot;| [[Microsoft]]/&lt;br&gt;[[Sybase]]
| style=&quot;text-align:center;&quot;| [[Transact-SQL|T-SQL]]
| Transact-SQL
|-
| style=&quot;text-align:center;&quot;| [[Mimer SQL]]
| style=&quot;text-align:center;&quot;| [[SQL/PSM]]
| SQL/Persistent Stored Module (implements SQL/PSM)
|-
| style=&quot;text-align:center;&quot;| [[MySQL]]
| style=&quot;text-align:center;&quot;| [[SQL/PSM]]
| SQL/Persistent Stored Module (implements SQL/PSM)
|-
| style=&quot;text-align:center;&quot;| [[Oracle Corporation|Oracle]]
| style=&quot;text-align:center;&quot;| [[PL/SQL]]
| Procedural Language/SQL (based on [[Ada (programming language)|Ada]])
|-
| style=&quot;text-align:center;&quot;| [[PostgreSQL]]
| style=&quot;text-align:center;&quot;| [[PL/pgSQL]]
| Procedural Language/PostgreSQL Structured Query Language (based on Oracle PL/SQL)
|-
| style=&quot;text-align:center;&quot;| [[PostgreSQL]]
| style=&quot;text-align:center;&quot;| [[PL/PSM]]
| Procedural Language/Persistent Stored Modules (implements SQL/PSM)
|}

In addition to the standard SQL/PSM extensions and proprietary SQL extensions, procedural and [[object-oriented programming language|object-oriented]] programmability is available on many SQL platforms via DBMS integration with other languages. The SQL standard defines [[SQL/JRT]] extensions (SQL Routines and Types for the Java Programming Language) to support [[Java (programming language)|Java]] code in SQL databases. [[SQL Server 2005]] uses the [[SQLCLR]] (SQL Server Common Language Runtime) to host managed [[Microsoft .NET|.NET]] assemblies in the database, while prior versions of SQL Server were restricted to using unmanaged extended stored procedures which were primarily written in C. PostgreSQL allows functions to be written in a wide variety of languages including [[Perl]], [[Python (programming language)|Python]], [[Tcl]], and C.

==Criticism==
SQL is a [[Declarative programming|declarative computer language]] intended for use with relational databases. Many of the original SQL features were inspired by, but violated the semantics of the [[relational model]] and its [[tuple relational calculus|tuple calculus]] realization. Recent extensions to SQL achieved relational completeness, but have worsened the violations, as documented in ''[[The Third Manifesto]]''.  Therefore, it cannot be considered relational in any significant sense, but is still widely called relational due to differentiation to other, pre-relational database languages which never intended to implement the relational model; due to its historical origin; and due to the use of the &quot;relational&quot; term by product vendors.

Other criticisms of SQL include:
* Implementations are inconsistent with the standard and, usually, incompatible between vendors.  In particular date and time syntax, string concatenation, &lt;code&gt;NULL&lt;/code&gt;s, and comparison [[case sensitivity]] vary from vendor to vendor.  A particular exception is [[PostgreSQL]], which strives for compliance, and [[SQLite]], which strives to follow PostgreSQL. {{Cn|date=October 2011}}
* The language makes it too easy to do a [[Cartesian product|Cartesian]] join (joining all possible combinations), which results in &quot;run-away&quot; result sets when &lt;code&gt;WHERE&lt;/code&gt; clauses are mistyped. Cartesian joins are so rarely used in practice that requiring an explicit &lt;code&gt;CARTESIAN&lt;/code&gt; keyword may be warranted. (''SQL 1992'' introduced the &lt;code&gt;CROSS JOIN&lt;/code&gt; keyword that allows the user to make clear that a Cartesian join is intended, but the shorthand &quot;comma-join&quot; with no predicate is still acceptable syntax, which still invites the same mistake.)
* It is also possible to misconstruct a &lt;code&gt;WHERE&lt;/code&gt; on an update or delete, thereby affecting more rows in a table than desired. (A work-around is to use transactions or habitually type in the WHERE clause first, then fill in the rest later.)
* The grammar of SQL is perhaps unnecessarily complex, borrowing a [[COBOL]]-like keyword approach, when a function-influenced syntax could result in more re-use of fewer grammar and syntax rules.
* The non-compliance of SQL to the relational model, and specifically to the 0th rule of [[Codd's 12 rules|Coddâs twelve rules]], is another source of complexity and incompatibility.

===Cross-vendor portability===
Popular implementations of SQL commonly omit support for basic features of Standard SQL, such as the &lt;code&gt;DATE&lt;/code&gt; or &lt;code&gt;TIME&lt;/code&gt; data types.  The most obvious such examples, and incidentally the most popular commercial, proprietary SQL DBMSs, are Oracle (whose &lt;code&gt;DATE&lt;/code&gt; behaves as &lt;code&gt;DATETIME&lt;/code&gt;,&lt;ref name = &quot;Ora DATE&quot;&gt;{{Cite book
| first1 = Diana | last1 = Lorentz
| first2 = Mary Beth | last2 = Roeser
| first3 = Sundeep | last3 = Abraham
| first4 = Angela | last4 = Amor
| first5 = Geeta | last5 = Arora
| first6 = Vikas | last6 = Arora
| first7 = Lance | last7 = Ashdown
| first8 = Hermann | last8 = Baer
| first9 = Shrikanth | last9 = Bellamkonda
| display-authors = 9
| series = Oracle Database Documentation Library
| publisher = Oracle USA, Inc.
| place = Redwood City, CA
| title = Oracle Database SQL Language Reference 11g Release 2 (11.2)
| chapter = Basic Elements of Oracle SQL: Data Types
| contribution = Oracle Built-in Data Types: &lt;code&gt;DATE&lt;/code&gt; Data Type
| origyear = 1996
| date = 2010-10
| accessdate = 2010-12-29
| url = http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/sql_elements001.htm#sthref154
| quote = For each &lt;code&gt;DATE&lt;/code&gt; value, Oracle stores the following information: century, year, month, date, hour, minute, and second
| postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}
}}.&lt;/ref&gt;&lt;ref name = &quot;Ora DATETIME&quot;&gt;{{Cite book
| first1 = Diana | last1 = Lorentz
| first2 = Mary Beth | last2 = Roeser
| first3 = Sundeep | last3 = Abraham
| first4 = Angela | last4 = Amor
| first5 = Geeta | last5 = Arora
| first6 = Vikas | last6 = Arora
| first7 = Lance | last7 = Ashdown
| first8 = Hermann | last8 = Baer
| first9 = Shrikanth | last9 = Bellamkonda
| display-authors = 9
| series = Oracle Database Documentation Library
| publisher = Oracle USA, Inc.
| place = Redwood City, CA
| title = Oracle Database SQL Language Reference 11g Release 2 (11.2)
| chapter = Basic Elements of Oracle SQL: Data Types
| contribution = Oracle Built-in Data Types: Datetime and Interval Data Types
| origyear = 1996
| date = 2010-10
| accessdate = 2010-12-29
| url = http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/sql_elements001.htm#sthref154
| quote = The datetime data types are &lt;code&gt;DATE&lt;/code&gt;â¦
| postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}
}}.&lt;/ref&gt; and lacks a &lt;code&gt;TIME&lt;/code&gt; type&lt;ref name = &quot;Ora TIME&quot;&gt;{{Cite book
| first1 = Diana | last1 = Lorentz
| first2 = Mary Beth | last2 = Roeser
| first3 = Sundeep | last3 = Abraham
| first4 = Angela | last4 = Amor
| first5 = Geeta | last5 = Arora
| first6 = Vikas | last6 = Arora
| first7 = Lance | last7 = Ashdown
| first8 = Hermann | last8 = Baer
| first9 = Shrikanth | last9 = Bellamkonda
| display-authors = 9
| series = Oracle Database Documentation Library
| publisher = Oracle USA, Inc.
| place = Redwood City, CA
| title = Oracle Database SQL Language Reference 11g Release 2 (11.2)
| chapter = Basic Elements of Oracle SQL: Data Types
| contribution = Oracle Built-in Data Types: ANSI, DB2, and SQL/DS Data Types
| origyear = 1996
| date = 2010-10
| accessdate = 2010-12-29
| url = http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/sql_elements001.htm#i54335
| quote = Do not define columns with the following SQL/DS and DB2 data types, because they have no corresponding Oracle data type:â¦ &lt;code&gt;TIME&lt;/code&gt;
| postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}}}.&lt;/ref&gt;) and the MS SQL Server (before the 2008 version).  As a result, SQL code can rarely be ported between database systems without modifications.

There are several reasons for this lack of portability between database systems:
* The complexity and size of the SQL standard means that most implementors do not support the entire standard.
* The standard does not specify database behavior in several important areas (e.g., [[index (database)|indexes]], file storageâ¦), leaving implementations to decide how to behave.
* The SQL standard precisely specifies the syntax that a conforming database system must implement. However, the standard's specification of the semantics of language constructs is less well-defined, leading to ambiguity.
* Many database vendors have large existing customer bases; where the SQL standard conflicts with the prior behavior of the vendor's database, the vendor may be unwilling to break [[backward compatibility]].
* Software vendors often desire to create incompatibilities with other products, as it provides a strong incentive for their existing users to remain loyal (see [[vendor lock-in]]).

==Standardization==
SQL was adopted as a standard by the [[American National Standards Institute]] (ANSI) in 1986 as SQL-86&lt;ref&gt;{{Cite book
| url = http://special.lib.umn.edu/findaid/xml/cbi00168.xml
| publisher = American National Standards Institute
| title = X3H2 Records, 1978â95
| chapter = Finding Aid
| postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}}}.&lt;/ref&gt; and the [[International Organization for Standardization]] (ISO) in 1987. The original SQL standard declared that the official pronunciation for SQL is &quot;es queue el&quot;.&lt;ref name=&quot;SQL-Fundamentals&quot;&gt;{{cite web
 | last = Chapple
 | first = Mike
 | title = SQL Fundamentals
 | work = Databases
 | publisher = About.com
 | url = http://databases.about.com/od/sql/a/sqlfundamentals.htm
 | accessdate = 2009-01-28 }}&lt;/ref&gt; Many English-speaking database professionals still use the nonstandard&lt;ref&gt;{{cite book
 |title=Understanding the New SQL: A Complete Guide
 |last=Melton
 |first=Jim
 |coauthors=Alan R Simon
 |year=1993
 |publisher=Morgan Kaufmann
 |isbn=1558602453
 |page=536
 |chapter= 1.2. What is SQL?
| quote = SQL (correctly pronounced &quot;ess cue ell,&quot; instead of the somewhat common &quot;sequel&quot;)â¦}}&lt;/ref&gt; pronunciation {{IPA |/ËsiËkwÉl/}} (like the word &quot;sequel&quot;).

Until 1996, the [[National Institute of Standards and Technology]] (NIST) data management standards program certified SQL DBMS compliance with the SQL standard. Vendors now self-certify the compliance of their products.&lt;ref&gt;{{cite web
 | last = Doll
 | first = Shelley
 | title = Is SQL a Standard Anymore?
 | work = TechRepublic's Builder.com
 | publisher = TechRepublic
 | date = June 19, 2002
 | url = http://articles.techrepublic.com.com/5100-10878_11-1046268.html
 | accessdate = 2010-01-07 }}&lt;/ref&gt;

The SQL standard has gone through a number of revisions, as shown below:
{| class=wikitable
|-
! Year !! Name !! style=&quot;width:125px;&quot;| Alias !! Comments
|- valign=top
| 1986 || SQL-86 || SQL-87 || First formalized by ANSI.
|- valign=top
| 1989 || SQL-89 || [[Federal Information Processing Standard|FIPS]] 127-1 || Minor revision, adopted as FIPS 127-1.
|- valign=top
| 1992 || [[SQL-92]] || SQL2, FIPS 127-2 || Major revision (ISO 9075), ''Entry Level'' SQL-92 adopted as FIPS 127-2.
|- valign=top
| 1999 || [[SQL:1999]] || SQL3 || Added regular expression matching, recursive queries, [[Database trigger|triggers]], support for procedural and control-of-flow statements, non-scalar types, and some object-oriented features.
|- valign=top
| 2003 || [[SQL:2003]] || SQL 2003 || Introduced [[XML]]-related features, ''window functions'', standardized sequences, and columns with auto-generated values (including identity-columns).
|- valign=top
| 2006 || SQL:2006 || SQL 2006 || ISO/IEC 9075-14:2006 defines ways in which SQL can be used in conjunction with XML. It defines ways of importing and storing XML data in an SQL database, manipulating it within the database and publishing both XML and conventional SQL-data in XML form. In addition, it enables applications to integrate into their SQL code the use of [[XQuery]], the XML Query Language published by the World Wide Web Consortium ([[W3C]]), to concurrently access ordinary SQL-data and XML documents.&lt;ref name=&quot;SQLXML2006&quot;&gt;{{cite book
 |title=SQL/XML:2006 - Evaluierung der StandardkonformitÃ¤t ausgewÃ¤hlter Datenbanksysteme
 |last=Wagner
 |first=Michael
 |coauthors=
 |year=2010
 |publisher=Diplomica Verlag
 |isbn=3836696096
 |page=100
 |chapter=
 |quote=}}&lt;/ref&gt;
|- valign=top
| 2008 || [[SQL:2008]] || SQL 2008 || Legalizes ORDER BY outside cursor definitions. Adds INSTEAD OF triggers.  Adds the TRUNCATE statement.&lt;ref name=&quot;iablog.sybase.com-paulley&quot;&gt;{{Cite document | date = 2008-7 | title = SQL:2008 now an approved ISO international standard | publisher = Sybase | url=http://iablog.sybase.com/paulley/2008/07/sql2008-now-an-approved-iso-international-standard/ | postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}}}.&lt;/ref&gt;
|}

Interested parties may purchase SQL standards documents from ISO or ANSI. A draft of SQL:2008 is freely available as a [[ZIP (file format)|zip]] archive.&lt;ref&gt;{{Cite document | url = http://www.wiscorp.com/sql200n.zip | format = Zip | title = SQL:2008 draft | publisher = Whitemarsh Information Systems Corporation | postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}}}.&lt;/ref&gt;

===Standard structure===
The SQL standard is divided into several parts, including:

*SQL Framework, provides logical concept
*SQL/Foundation, defined in ISO/IEC 9075, Part 2. This part of the standard contains the most central elements of the language. It consists of both ''mandatory and optional'' features.
*The SQL/Bindings, specifies how SQL is to be bound to variable host languages, excluding Java.
*The [[SQL/CLI]], or '''Call-Level Interface''', part is defined in ISO/IEC 9075, Part 3. SQL/CLI defines common interfacing components (structures and procedures) that can be used to execute SQL statements from applications written in other programming languages. SQL/CLI is defined in such a way that SQL statements and SQL/CLI procedure calls are treated as separate from the calling application's source code. [[Open Database Connectivity]] is a well-known superset of SQL/CLI. This part of the standard consists solely of ''mandatory'' features.
*The [[SQL/PSM]], or '''Persistent Stored Modules''', part is defined by ISO/IEC 9075, Part 4. SQL/PSM standardizes procedural extensions for SQL, including flow of control, condition handling, statement condition signals and resignals, cursors and local variables, and assignment of expressions to variables and parameters. In addition, SQL/PSM formalizes declaration and maintenance of persistent database language routines (e.g., &quot;stored procedures&quot;). This part of the standard consists solely of ''optional'' features.
*The [[SQL/MED]], or '''Management of External Data''', part is defined by ISO/IEC 9075, Part 9. SQL/MED provides extensions to SQL that define foreign-data wrappers and datalink types to allow SQL to manage external data. External data is data that is accessible to, but not managed by, an SQL-based DBMS. This part of the standard consists solely of ''optional'' features.
*The [[SQL/OLB]], or '''Object Language Bindings''', part is defined by ISO/IEC 9075, Part 10. SQL/OLB defines the syntax and symantics of [[SQLJ]], which is SQL embedded in Java. The standard also describes mechanisms to ensure binary portability of SQLJ applications, and specifies various Java packages and their contained classes. This part of the standard consists solely of ''optional'' features.
*The SQL/MM (Multimedia), This extends SQL to deal intelligently with large, complex and sometimes streaming items of data, such as video, audio and [[Georeference|spatial data]].
*The [[SQL/Schemata]], or '''Information and Definition Schemas''', part is defined by ISO/IEC 9075, Part 11. SQL/Schemata defines the Information Schema and Definition Schema, providing a common set of tools to make SQL databases and objects self-describing. These tools include the SQL object identifier, structure and integrity constraints, security and authorization specifications, features and packages of ISO/IEC 9075, support of features provided by SQL-based DBMS implementations, SQL-based DBMS implementation information and sizing items, and the values supported by the DBMS implementations.&lt;ref name=&quot;ISO/IEC 9075-11:2008&quot;&gt;{{Cite journal
 | title = ISO/IEC 9075-11:2008: Information and Definition Schemas (SQL/Schemata)
 | page = 1
 | year = 2008
}}&lt;/ref&gt; This part of the standard contains both ''mandatory and optional'' features.
*The [[SQL/JRT]], or '''SQL Routines and Types for the Java Programming Language''', part is defined by ISO/IEC 9075, Part 13. SQL/JRT specifies the ability to invoke static Java methods as routines from within SQL applications. It also calls for the ability to use Java classes as SQL structured user-defined types. This part of the standard consists solely of ''optional'' features.
*The [[SQL/XML]], or '''XML-Related Specifications''', part is defined by ISO/IEC 9075, Part 14. SQL/XML specifies SQL-based extensions for using XML in conjunction with SQL. The XML data type is introduced, as well as several routines, functions, and XML-to-SQL data type mappings to support manipulation and storage of XML in an SQL database.&lt;ref name=&quot;SQLXML2006&quot; /&gt; This part of the standard consists solely of ''optional'' features.

==Alternatives==

A distinction should be made between alternatives to relational query languages and alternatives to SQL. Below are proposed relational alternatives to SQL. See [[navigational database]] for alternatives to relational:
* [[.QL]] - object-oriented Datalog
* [[4th Dimension (Software)|4D Query Language]] (4D QL)
* [[Datalog]]
* [[HTSQL]] - URL based query method
* [[IBM Business System 12]] (IBM BS12) - one of the first fully relational database management systems, introduced in 1982
* [[ISBL]]
* [[Java Persistence Query Language]] (JPQL) - The query language used by the [http://www.oracle.com/technetwork/articles/javaee/jpa-137156.html Java Persistence API] and [[Hibernate (Java)|Hibernate]] persistence library
* [[Language Integrated Query|LINQ]]
* [[Object Query Language]]
* [[Query by Example|QBE (Query By Example)]] created by MoshÃ¨ Zloof, IBM 1977
* [[QUEL query languages|Quel]] introduced in 1974 by the U.C. Berkeley Ingres project.
* [[Tutorial D]]
* [[SBQL]] - the Stack Based Query Language ([http://www.sbql.pl SBQL])
* [[UnQL]] - the '''Unstructured''' Query Language, a functional superset of SQL, developed by the authors of [[SQLite]] and [[CouchDB]]
* [[XQuery]]

==See also==
* [[Comparison of object-relational database management systems]]
* [[Comparison of relational database management systems]]
* [[D (data language specification)]]
* [[D4 (programming language)]] (an implementation of D)
* [[Hierarchical model]]
* [[List of relational database management systems]]
* [[MUMPS]]
* [[NoSQL]]

== Notes ==

{{Reflist|30em}}

== References ==

{{refbegin}}
* {{Cite journal | url = http://www.acm.org/classics/nov95/toc.html | title = A Relational Model of Data for Large Shared Data Banks | first = Edgar F | last = Codd | journal = Communications of the ACM | volume = 13 | date = June 1970 | pages = 377â87 | issue = 6 | doi = 10.1145/362384.362685 | postscript = &lt;!-- Bot inserted parameter. Either remove it; or change its value to &quot;.&quot; for the cite to end in a &quot;.&quot;, as necessary. --&gt;{{inconsistent citations}}}}.
* [[c2:SqlFlaws|Discussion on alleged SQL flaws]] (C2 wiki)
{{refend}}

==External links==
{{wikibooks|Structured Query Language}}
{{wikibooks|SQL dialects reference}}
{{wikiversity|Topic:Computer Science}}
* [http://www.mcjones.org/System_R/SQL_Reunion_95/sqlr95.html ''1995 SQL Reunion: People, Projects, and Politics'', by Paul McJones (ed.)]: transcript of a reunion meeting devoted to the personal history of relational databases and SQL.
* [http://special.lib.umn.edu/findaid/xml/cbi00168.xml American National Standards Institute. X3H2 Records, 1978â1995] [[Charles Babbage Institute]] Collection documents the H2 committeeâs development of the NDL and SQL standards.
* [http://www.cbi.umn.edu/oh/display.phtml?id=317 Oral history interview with Donald D. Chamberlin] [[Charles Babbage Institute]] In this oral history Chamberlin recounts his early life, his education at [[Harvey Mudd College]] and [[Stanford University]], and his work on relational database technology. Chamberlin was a member of the System R research team and, with [[Raymond F. Boyce]], developed the SQL database language. Chamberlin also briefly discusses his more recent research on XML query languages.
* [http://troels.arvin.dk/db/rdbms/ Comparison of Different SQL Implementations] This comparison of various SQL implementations is intended to serve as a guide to those interested in porting SQL code between various RDBMS products, and includes comparisons between SQL:2008, PostgreSQL, DB2, MS SQL Server, MySQL, Oracle, and Informix.

{{SQL}}
{{Databases}}
{{Query languages}}
{{IBM}}
{{ISO standards}}

{{DEFAULTSORT:Sql}}
[[Category:Articles with example SQL code]]
[[Category:Computer languages]]
[[Category:Data modeling languages]]
[[Category:Declarative programming languages]]
[[Category:Query languages]]
[[Category:Relational database management systems]]
[[Category:SQL| ]]

[[ar:Ø¥Ø³ ÙÙÙ Ø¥Ù]]
[[bn:à¦à¦¸à¦à¦¿à¦à¦à¦²]]
[[be:SQL]]
[[be-x-old:SQL]]
[[bar:SQL]]
[[bs:SQL]]
[[br:SQL]]
[[bg:SQL]]
[[ca:Structured Query Language]]
[[cs:SQL]]
[[da:Structured Query Language]]
[[de:SQL]]
[[et:StruktuurpÃ¤ringukeel]]
[[el:SQL]]
[[es:SQL]]
[[eo:SQL]]
[[eu:SQL]]
[[fa:Ø§Ø³âÚ©ÛÙØ§Ù]]
[[fr:Structured Query Language]]
[[ga:Teanga StruchtÃºrtha Iarratas]]
[[ko:SQL]]
[[hi:à¤à¤¸à¤à¥à¤¯à¥à¤à¤²]]
[[hr:SQL]]
[[id:SQL]]
[[ia:SQL]]
[[is:SQL]]
[[it:SQL]]
[[he:SQL]]
[[ku:SQL]]
[[lv:SQL]]
[[lt:SQL]]
[[hu:SQL]]
[[ml:à´à´¸àµ.à´àµà´¯àµ.à´àµ½.]]
[[ms:SQL]]
[[cdo:SQL]]
[[nl:SQL]]
[[ja:SQL]]
[[no:Structured Query Language]]
[[nn:SQL]]
[[mhr:SQL]]
[[pl:SQL]]
[[pt:SQL]]
[[ro:SQL]]
[[ru:SQL]]
[[sq:SQL]]
[[simple:Structured Query Language]]
[[sk:SQL]]
[[sl:SQL]]
[[sr:SQL]]
[[fi:SQL]]
[[sv:SQL]]
[[ta:à®µà®¿à®©à®µà®²à¯ à®à®®à¯à®ªà¯à®ªà¯ à®®à¯à®´à®¿]]
[[tt:SQL]]
[[th:à¸ à¸²à¸©à¸²à¸ªà¸­à¸à¸à¸²à¸¡à¹à¸à¸´à¸à¹à¸à¸£à¸à¸ªà¸£à¹à¸²à¸]]
[[tg:SQL]]
[[tr:SQL]]
[[uk:SQL]]
[[vi:SQL]]
[[yo:SQL]]
[[zh:SQL]]</rev></revisions></page></pages></query></api>
