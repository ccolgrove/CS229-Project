<?xml version="1.0"?><api><query><pages><page pageid="59441" ns="0" title="DLL Hell"><revisions><rev xml:space="preserve">In [[computing]], '''DLL Hell''' is a term for the complications that arise when working with [[dynamic link library|dynamic link libraries]] (DLLs) used with [[Microsoft Windows]] [[operating system]]s,&lt;ref&gt;{{cite web|url=http://msdn.microsoft.com/en-us/magazine/bb985026.aspx|title=Avoiding DLL Hell: Introducing Application Metadata in the Microsoft .NET Framework|publisher=Microsoft|month=October|year=2000}}&lt;/ref&gt; particularly legacy 16-bit editions which all run in a single memory space.
While the phrase is Windows-specific and a derivation of the general cross-platform phrase &quot;[[dependency hell]]&quot;, the rhyme &quot;DLL hell&quot; makes its use popular for discussing a general Windows-related dependency hell case.

DLL Hell often shows up in a Windows alert pop-up that reports something similar to ''&quot;A&amp;nbsp;Required DLL File, Z.DLL, was not found&quot;'' or ''&quot;The procedure entry point Y couldn't be located in X.DLL&quot;'' when users try to run an application, or during startup.  This can also manifest itself more quietly as applications not working properly.
It takes a number of forms, as detailed below.

== Problems ==
There are a number of problems commonly encountered with DLLs &amp;ndash; especially after numerous applications have been installed and uninstalled on a system.
The difficulties include conflicts between DLL versions, difficulty in obtaining required DLLs, and having many unnecessary DLL copies.

===Incompatible versions===
A particular version of a library can be compatible with some (and incompatible with other) programs that use it. Windows has been particularly vulnerable to this because of its emphasis on dynamic linking of C++ libraries and [[Object Linking and Embedding]] (OLE) objects. C++ classes export many methods, and a single change to the class (such as a new virtual method) can make it incompatible with programs that were built against an earlier version. Object Linking and Embedding has some very strict rules to prevent thisâinterfaces are required to be stable and memory managers are not shared. But this is not enough, for the semantics of a class can change. A &quot;bug fix&quot; for one application may be the removal of a &quot;feature&quot; from another. Before [[Windows 2000]], Windows was vulnerable to this because the [[Component Object Model|COM]] class table was shared across all users and processes. Only one COM object, in one DLL/EXE could be declared as having a specific COM ClassID. If any program needed to create an instance of that class, it got whatever was the current centrally registered implementation. As a result, an installation of a program that installs a new version of a common object may inadvertently break other programs that were previously installed.

===DLL stomping===
A common and troublesome problem occurs when a newly-installed program overwrites a working system DLL with an earlier, incompatible version. A famous example of this was the &lt;code&gt;ctl3d.dll&lt;/code&gt; and &lt;code&gt;ctl3dv2.dll&lt;/code&gt; libraries for [[Windows 3.1]], which had numerous updated versions appearing in the wild.&lt;ref name=Ctl3D&gt;{{cite web| url=http://support.microsoft.com/search/default.aspx?query=CTL3Dv2.DLL |title=A summary of CTL3D.DLL articles in Microsoft Support Knowledge Base|publisher=Microsoft}}&lt;/ref&gt; DLL Stomping occurs because:
:* Microsoft in the past distributed runtime DLLs as shared system components,&lt;ref&gt;[http://support.microsoft.com/kb/326922 Redistribution of the shared C runtime component in Visual C++ 2005 and in Visual C++ .NET]&lt;/ref&gt; (originally C:\WINDOWS and C:\WINDOWS\SYSTEM), as a way of efficiently sharing code in a shared-memory OS with limited RAM and disk space. Consequently, third-party developers also distributed these in such a manner.
:* Application installers are typically executed in a privileged security context that has access to install DLLs into the system directories, and to edit the system Registry to register new DLLs as [[Component Object Model|COM]] objects.  A poorly written or misconfigured installer can therefore downgrade a system library on legacy versions of Windows on which [[Windows File Protection]] or [[Windows Resource Protection]] does not roll back the change.  On Windows Vista and later, only the &quot;trusted installer&quot; account can make changes to core operating system libraries.
:* Windows applications are permitted to include OS updates in their own installation programs. That is, many Microsoft DLLs are ''redistributable'', meaning the applications get to include them if they need the services of the particular libraries.
:* Before [[Windows Installer]], Windows installers historically were commercial products; many people attempted to write their own installers, overlooking or mishandling versioning problems in the process.{{Citation needed|date=August 2008}}
:* Some development environments did not automatically add a version resource in their compiled libraries, so many developers overlooked this aspect. Checking file dates, overwriting existing files or skipping the copy operation if the DLL was already installed were the only options available in lieu of correct versioning.{{Citation needed|date=June 2010}}
:* Sometimes the OS itself removes or replaces DLLs with older or obsolete versions. For example, Windows 2000 would install black and white printer DLLs on top of color-aware DLLs, if a black and white printer was installed after the color printer.&lt;ref&gt;[http://support.microsoft.com/kb/830490 KB 830490: HP Color LaserJet printer prints only in grayscale or in black-and-white on your Windows 2000 SP4-based computer&lt;!-- Bot generated title --&gt;]&lt;/ref&gt;

===Incorrect COM registration===
In [[Component Object Model|COM]] and other parts of Windows, prior to the introduction of side-by-side Registry-free assemblies,&lt;ref&gt;{{cite web|url=http://msdn.microsoft.com/en-us/library/ms973913.aspx|title=Registration-Free Activation of COM Components: A Walkthrough&quot;|publisher=[[Microsoft]]|publisher=Leslie Muller/Steve White|date=July 2005}}&lt;/ref&gt; the [[Windows Registry|Registry]] was used for determining which underlying DLL to use. If a different version of a module was registered, this DLL would be loaded instead of the expected one. This scenario could be caused by conflicting installations that register different versions of the same libraries, in which case the last installation would prevail.

===Shared in-memory modules===
16-bit versions of Windows load only one instance of any given DLL; all applications reference the same in-memory copy, until no applications are using it and it is unloaded from memory. (For 32-bit and 64-bit versions of Windows, inter-process sharing occurs only where different executables load a module from exactly the same directory; the code but not the [[Stack (data structure)|stack]] is shared between processes through a process called &quot;memory mapping&quot;.)  Thus, even when the desired DLL is located in a directory where it can be expected to be found, such as in the system directory or the application directory, neither of these instances will be used if another application has started with an incompatible version from a third directory.  This issue can manifest itself as a 16-bit application error that occurs only when another 16-bit application is running.

===Lack of serviceability===
In direct conflict with the DLL stomping problem: If updates to a DLL do not affect all applications which use it, then it becomes ''much'' harder to 'service' the DLL - that is, to eliminate problems which exist in the current versions of the DLL. (Security fixes are a particularly compelling, and painful, case.) Instead of fixing just the latest version of the DLL, the implementor must ideally make their fixes, and test them for compatibility, on every released version of the DLL.

==Causes==
DLL incompatibility has been caused by:
*Memory constraints, combined with lack of separation of process memory space in 16-bit versions of Windows
*Lack of enforced standard versioning, naming, and file system location [[Model (abstract)|schemata]] for DLLs;
*Lack of an enforced standard method for software installation and removing ([[package management]]);
*Centralized authoritative support for DLL [[application binary interface]] management and safeguards, allowing incompatible DLLs with the same file name and internal version numbers to be released;
*Overly simplified management tools, preventing the identification of changed or problematic DLLs by users and administrators.
*Developers breaking backward-compatibility of functions in shared modules;
*Microsoft releasing out-of-band updates to operating system runtime components;
*Inability of earlier versions of Windows to run side-by-side conflicting versions of the same library;
*Reliance on the current directory or ''%PATH%'' environment variable, both of which vary over time and from system to system, to find dependent DLLs (instead of loading them from an explicitly configured directory.)
* Developers re-using the ClassIDs from sample applications for the COM interfaces of their applications, rather than generating their own new [[Globally unique identifier|GUIDs]].

DLL Hell was a very common phenomenon on pre-Windows NT versions of Microsoft operating systems, the primary cause being that the 16-bit operating systems did not restrict processes to their own memory space, thereby not allowing them to load their own version of a shared module that they were compatible with. Application installers were expected to be good citizens and verify DLL version information before overwriting the existing system DLLs. Standard tools to simplify application deployment (which always involves shipping the dependent operating system DLLs) were provided by Microsoft and other 3rd party tools vendors. Microsoft even required application vendors to use a standard installer and have their installation program certified to work correctly, before being granted use of the Microsoft logo. The good citizen installer approach did not mitigate the problem, as the rise in popularity of the Internet provided more opportunities to obtain non-conforming applications.

===Use by malware===
The ambiguity with which DLLs that are not fully qualified can be loaded in the Windows operating system has been exploited by malware in recent years, opening a new class of vulnerability that affects applications from many different software vendors, as well as Windows itself.&lt;ref&gt;{{cite web|url=http://support.microsoft.com/kb/2389418|title=Secure Loading of Libraries to Prevent DLL Preloading Attacks|accessdate=2011-07-19|date=2011-06-11|publisher=Microsoft}}&lt;/ref&gt;

==Solutions==
Various forms of DLL hell have been solved or mitigated over the years.

===Static linking===
One of the simplest solutions to DLL Hell in an application is to [[Static library|statically link]] against all the libraries.&lt;ref name=&quot;threatormenace&quot;/&gt; This is common in C/C++ applications, where, instead of having to worry about which version of ''MFC42.DLL'' is installed, the application is compiled to be statically linked against the same libraries. This eliminates the DLLs entirely, and is viable for standalone applications which only use libraries which offer a static option, like  [[Microsoft Foundation Class Library]] does. The main purpose of DLLs (runtime library sharing between programs to reduce memory overhead) is sacrificed though giving more [[software bloat]] and can prevent proper propagation of security fixes.

===Windows File Protection===
The DLL overwriting problem (referred to as ''DLL Stomping'' inside Microsoft) was somewhat reduced with [[Windows File Protection]] (WFP)&lt;ref&gt;[http://www.microsoft.com/whdc/winlogo/drvsign/wfp.mspx Windows File Protection and Windows]&lt;/ref&gt; which was introduced in [[Windows 2000]].&lt;ref name=&quot;endofdllhell&quot;/&gt; This prevents unauthorized applications from overwriting system DLLs, unless they use the specific [[Windows API]]s that permit this. There is still a risk that updates from Microsoft (such as [[Internet Explorer 7]]) are incompatible with existing applications.

Third-party applications cannot stomp on OS files unless they bundle legitimate Windows updates with their installer, or if they disable the [[Windows File Protection]] service during installation, and on Windows Vista or later also take ownership of system files and grant themselves access.  The [[System File Checker|SFC]] utility could revert these changes at any time.

===Running conflicting DLLs simultaneously===
The solutions here consist of having different copies of the same DLLs for each application, both on-disk and in memory.

An easy manual solution to conflicts was placing the different versions of the problem DLL into the applications' folders, rather than a common system-wide folder. This works in general as long as the application is 32-bit or 64-bit, and that the DLL does not use shared memory.  In the case of 16-bit applications, the two applications cannot be executed simultaneously on a 16-bit platform, or in the same 16-bit virtual machine under a 32-bit operating system.  [[Object Linking and Embedding|OLE]] prevented this before Windows XP, because earlier versions of Windows had a single Registry of COM objects for all applications.

Windows XP introduced a solution called ''[[Side-by-side assembly]]''
([http://msdn2.microsoft.com/en-us/library/ms811700.aspx MSDN page]), which loads separate copies of DLLs for each application that requires them (and thus allows applications that require conflicting DLLs to run simultaneously).  This approach eliminates conflicts by allowing applications to load unique versions of a module into their address space, while preserving the primary benefit of sharing DLLs between applications (i.e. reducing memory use) by using memory mapping techniques to share common code between different processes that do still use the same module. Yet DLLs using shared data between multiple processes cannot take this approach.&lt;ref&gt;{{cite web|url=http://msdn.microsoft.com/en-us/library/h90dkhs0(VS.71).aspx|title=How do I share data in my DLL with an application or with other DLLs?|publisher=[[Microsoft]]|accessdate=2008-11-11}}&lt;/ref&gt;  One negative side effect is orphaned instances of DLLs may not be updated during automated processes.

===Portable Applications===
[[Portable Applications]] (also known as &quot;portable apps&quot;) are an effective way to reduce DLL problems, since every program contains their required DLLs bundled-in (also sometimes called &quot;private libraries&quot;&lt;ref name=&quot;endofdllhell&quot;/&gt;). Mechanism is the Windows shared library policy which favours locally (application directory) available DLLs before the one in the system library path.&lt;ref name=&quot;sharedlibpolicy&quot;/&gt; Sometimes applications run in a &quot;bubble&quot;, using [[Application virtualization]], which avoids installing DLL files into the operating system.

=== Other countermeasures ===
There are other countermeasures to avoid DLL Hell, some of which may have to be used simultaneously:
Some other features that help to mitigate the problem are
* Installation tools are now bundled into [[Microsoft Visual Studio]], one of the main environments for Windows development. These tools perform version checking before DLL installation, and can include predefined installation packages in a .MSI installation. This allows third party applications to integrate OS component updates without having to write their own installers for these components.
* [[System Restore]] can recover a system from a bad installation, including registry damage. While this does not prevent the problem, it makes it easier to recover from.
* WinSxS (Windows Side-by-Side) folder, which allows multiple versions of the same libraries to co-exist.
* Run 16-bit applications in separate memory space under a 32-bit version of Windows, to allow two applications to use conflicting versions of the same DLL at the same time.
* Use a version of Windows that includes [[Windows File Protection]].  [[Windows Me]] and [[Windows 2000]], both released in 2000, support this form of system file protection, as do [[Windows XP]] and [[Windows Server 2003]].  Its replacement, [[Windows Resource Protection]], was introduced in Windows Vista and Windows Server 2008, and uses a different method of protecting system files from being changed.
* Registration-free COM: [[Windows XP]] introduced a new mode of COM object registration called &quot;''Registration-free COM''&quot; that was not well-publicized due to the simultaneous release of information related to .NET. This feature makes it possible for applications that need to install COM objects to store all the required COM registry information in the application's directory, instead of in the global registry, where strictly speaking if only a single application will ever use it is all that is needed. Thus, it provides a mechanism for multiple versions of the same DLL to be present at the same time as needed to cater for multiple applications (Microsoft calls this &quot;[[Side-by-Side Assembly]]&quot;&lt;ref&gt;[http://msdn2.microsoft.com/en-us/library/aa376307.aspx Side-by-side Assemblies (Windows)]&lt;/ref&gt;). DLL hell can be substantially avoided using Registration-free COM, the only limitation being it requires at least [[Windows XP]] or later Windows versions and that it must not be used for EXE COM servers or system-wide components such as [[Microsoft Data Access Components|MDAC]], [[MSXML]], [[DirectX]] or [[Internet Explorer]].
* Shipping the operating system with a capable [[package management system]] that is able to track the DLL dependencies, encouraging the use of the package manager and discouraging manual installation of DLLs.  [[Windows Installer]], included with [[Windows Me]], [[Windows 2000]] and all later versions provides this functionality.
* Having a central database or authority for DLL conflict resolution and software distribution. Changes to a library can be submitted to this authority; thus, it can make sure compatibility is preserved in the developed branches. If some older software is incompatible with the current library, the authority can provide a compatibility interface for it, or bundle the old version as a distinct package.
* If software developers need to customize a library, and if the main library release is unlikely to incorporate the changes that they need, they can ship the customized DLL for the program's private use (commonly by placing it in the program's private directory) or statically link the program against the customized library.
* While DLLs are best for modularizing applications and the system's components and as third-party libraries, their usage is not imperative in all cases. For example, if an application needs a library that will not be used anywhere else, it can be linked statically, with no space penalty and with a speed gain.
* Windows Vista and later use a special ''TrustedInstaller'' service to install operating system files.  Other user accounts, including the SYSTEM, have no access to overwrite core system binaries.  Windows 7 expands this functionality to some critical parts of the Registry.
* [[Web-based application]]s avoid many side-by-side problems by running the bulk of the code on a server and using a browser interface on the client.

== See also ==
* [[Dependency hell]]
* [[Portable application]]
* [[Portable application creators]]
* [[JAR hell]]

==References==
{{Reflist|2|refs=&lt;ref name=&quot;sharedlibpolicy&quot;&gt;{{cite web
| url=http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html
| title=Using static and shared libraries across platforms; Row 9: Library Path
| date=2007-06-15
| archiveurl=http://web.archive.org/web/20080601183608/http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html
| archivedate=2008-06-01
| last=Desitter
| first=Arnaud
| publisher=ArnaudRecipes
| accessdate=2010-07-07
}}&lt;/ref&gt;
&lt;ref name=&quot;endofdllhell&quot;&gt;{{cite web
| url=http://msdn.microsoft.com/library/techart/dlldanger1.htm
| title=The End of DLL Hell
| date=2000-01-11
| archiveurl=http://web.archive.org/web/20010605023737/http://msdn.microsoft.com/library/techart/dlldanger1.htm
| archivedate=2001-06-05
| last=Anderson
| first=Rick
| publisher=microsoft.com
| accessdate=2010-07-07
}}&lt;/ref&gt;
&lt;ref name=&quot;threatormenace&quot;&gt;{{cite web
| url=http://www.ddj.com/184410810
| title=Windows DLLs: Threat or Menace?
| date=1998-06-01
| archiveurl=http://web.archive.org/web/20100807195510/http://www.ddj.com/184410810
| archivedate=2006-06-20
| last=Pfeiffer
| first=Tim
| publisher=Dr. Dobbs Journal
| accessdate=2010-07-07
}}&lt;/ref&gt;}}

==External links==
* [http://www.microsoft.com/technet/technetmag/issues/2007/01/WindowsConfidential/default.aspx Getting Out of DLL Hell] on Microsoft TechNet
* [http://msdn.microsoft.com/en-us/library/ms973843.aspx Simplifying Deployment and Solving DLL Hell with the .NET Framework] on MSDN
* [http://msdn.microsoft.com/msdnmag/issues/1000/metadata/default.aspx Avoiding DLL Hell: Introducing Application Metadata in the Microsoft .NET Framework] by Matt Pietrek
* [http://www.ddj.com/dept/windows/184416837 Dr. Dobb's on DLL Hell] (details on LoadLibraryEx)
* [http://discuss.fogcreek.com/joelonsoftware/default.asp?cmd=show&amp;ixPost=2899 Joel on Software discussion]
* [http://dllcity.com/dll-hell.php Article on DLL Hell]

{{DEFAULTSORT:Dll Hell}}
[[Category:Anti-patterns]]
[[Category:Microsoft Windows]]
[[Category:Computer libraries]]
[[Category:Windows administration]]
[[Category:Computer jargon]]

[[bg:DLL-Ð°Ð´]]
[[da:DLL-helvede]]
[[de:DLL-Konflikt]]
[[es:Infierno de las DLL]]
[[ko:DLL ì§ì¥]]
[[id:DLL Hell]]
[[he:DLL hell]]
[[hu:DLL hell]]
[[ja:DLLå°ç]]
[[pt:Inferno de DLLs]]
[[ru:DLL hell]]
[[zh:DLLå°ç]]</rev></revisions></page></pages></query></api>
