<?xml version="1.0"?><api><query><pages><page pageid="53189" ns="0" title="GNU bison"><revisions><rev xml:space="preserve">{{Infobox software
| name = GNU Bison
| logo =
| developer = The [[GNU Project]]
| frequently updated = yes
| operating system = [[Cross-platform]]
| genre = [[Parser generator]]
| license = [[GNU General Public License|GPL]] ([[free software]])
| website = [http://www.gnu.org/software/bison/ www.gnu.org/software/bison]
|}}
{{Portal|Free software}}
'''GNU bison''', commonly known as Bison, is a [[parser generator]] that is part of the [[GNU Project]]. Bison reads a specification of a [[context-free language]], warns about any [[parsing]] ambiguities, and generates a parser (either in [[C (programming language)|C]], [[C++]], or [[Java (programming language)|Java]]) which reads sequences of [[Lexical analysis#Token|tokens]] and decides whether the sequence conforms to the syntax specified by the grammar.  Bison&lt;ref&gt;{{Cite book
  | last = Levine
  | first = John
  | authorlink = John Levine
  | coauthors =
  | title = flex &amp;amp; bison
  | publisher = O'Reilly Media
  | date = August 2009
  | location =
  | pages = 304
  | url = http://oreilly.com/catalog/9780596155988
  | doi =
  | id =
  | isbn = 978-0-596-15597-1}}&lt;/ref&gt; generates [[LALR parsers]]. Bison also supports âGeneralized Left-to-right Rightmostâ ([[GLR parser|GLR]]) parsers for grammars that are not [[LALR]].

In [[POSIX]] mode, Bison is compatible with [[yacc]], but also supports several improvements over this earlier program. [[Flex lexical analyser|flex]], an automatic [[Lexical analysis|lexical analyser]], is often used with Bison, to tokenise input data and provide Bison with tokens.

Bison is licensed as [[free software]] and is available in [[source code]] form. Earlier releases of bison used to stipulate that parts of its output were protected under the [[GPL]], due to the inclusion of the yyparse() function from the original source code in the output. However, an exception was made, to allow other licenses to apply to the use of the output.&lt;ref&gt;[http://www.gnu.org/software/bison/manual/html_node/Conditions.html GNU Bison Manual: Conditions for Using Bison]&lt;/ref&gt;

==A complete reentrant parser example==

The example shows how to use bison and flex to do a simple calculator (only add and multiply) and provides also an example for creating an [[abstract syntax tree]]. The next two files provide definition and implementation of the syntax tree functions.

&lt;source lang=&quot;c&quot;&gt;
/*
 * Expression.h 
 * Definition of the structure used to build the syntax tree.
 */
#ifndef __EXPRESSION_H__
#define __EXPRESSION_H__

/**
 * @brief The operation type
 */
typedef enum tagEOperationType
{
    eVALUE,
    eMULTIPLY,
    ePLUS
}EOperationType;

/**
 * @brief The expression structure
 */
typedef struct tagSExpression
{
	EOperationType type;///&lt; type of operation

	int value;///&lt; valid only when type is eVALUE
	struct tagSExpression* left; ///&lt; left side of the tree
	struct tagSExpression* right;///&lt; right side of the tree
}SExpression;

/**
 * @brief It creates an identifier
 * @param value The number value
 * @return The expression or NULL in case of no memory
 */
SExpression* createNumber(int value);

/**
 * @brief It creates an operation
 * @param type The operation type
 * @param left The left operand
 * @param right The right operand
 * @return The expression or NULL in case of no memory
 */
SExpression* createOperation(
			EOperationType type,
			SExpression *left,
			SExpression *right);

/**
 * @brief Deletes a expression
 * @param b The expression
 */
void deleteExpression(SExpression *b);

#endif // __EXPRESSION_H__
&lt;/source&gt;

&lt;source lang=&quot;c&quot;&gt;
/*
 * Expression.c 
 * Implementation of functions used to build the syntax tree.
 */

#include &quot;Expression.h&quot;

#include &lt;stdlib.h&gt;

/**
 * @brief Allocates space for expression
 * @return The expression or NULL if not enough memory
 */
static SExpression* allocateExpression()
{
	SExpression* b = malloc(sizeof *b);

	if( b == NULL ) return NULL;

	b-&gt;type = eVALUE;
	b-&gt;value = 0;

	b-&gt;left = NULL;
	b-&gt;right = NULL;

	return b;
}

SExpression* createNumber(int value)
{
	SExpression* b = allocateExpression();

        if( b == NULL ) return NULL;

	b-&gt;type = eVALUE;
	b-&gt;value = value;

	return b;
}

SExpression *createOperation( 
			EOperationType type,
                        SExpression *left,
                        SExpression *right)
{
	SExpression* b = allocateExpression();

	if( b == NULL ) return NULL;

	b-&gt;type = type;
	b-&gt;left = left;
	b-&gt;right = right;

	return b;
}

void deleteExpression(SExpression *b)
{
	if (b == NULL) return;

	deleteExpression(b-&gt;left);
	deleteExpression(b-&gt;right);

	free(b);
}
&lt;/source&gt;

Since the tokens are provided by flex we must provide the means to communicate between the parser and the lexer. This is accomplished by defining the ''YYSTYPE''. More details on this can be found on the flex manual.&lt;ref name=&quot;flex-bison-bridge&quot;&gt;[http://flex.sourceforge.net/manual/Bison-Bridge.html GNU Bison Manual: C Scanners with Bison Parsers]&lt;/ref&gt; 

&lt;source lang=&quot;c&quot;&gt;
/*
 * TypeParser.h
 * Definition of the structure used internally by the parser and lexer
 * to exchange data.
 */

#ifndef __TYPE_PARSER_H__
#define __TYPE_PARSER_H__

#include &quot;Expression.h&quot;

/**
 * @brief The structure used by flex and bison
 */
typedef union tagTypeParser
{
	SExpression *expression;
	int value;
}STypeParser;

// define the type for flex and bison
#define YYSTYPE STypeParser

#endif // __TYPE_PARSER_H__
&lt;/source&gt;

Since in this sample we use the reentrant version of both flex and yacc we are forced to provide parameters for the ''yylex'' function, when called from ''yyparse''.&lt;ref name=&quot;flex-bison-bridge&quot; /&gt;

&lt;source lang=&quot;c&quot;&gt;
/*
 * ParserParam.h
 * Definitions of the parameters for the reentrant functions
 * of flex (yylex) and bison (yyparse)
 */

#ifndef __PARSERPARAM_H__
#define __PARSERPARAM_H__

#ifndef YY_NO_UNISTD_H
#define YY_NO_UNISTD_H 1
#endif // YY_NO_UNISTD_H

#include &quot;TypeParser.h&quot;
#include &quot;Lexer.h&quot;
#include &quot;Expression.h&quot;

/**
 * @brief structure given as argument to the reentrant 'yyparse' function.
 */
typedef struct tagSParserParam
{
	yyscan_t scanner;
	SExpression *expression;
}SParserParam;

// the parameter name (of the reentrant 'yyparse' function)
// data is a pointer to a 'SParserParam' structure
#define YYPARSE_PARAM	data

// the argument for the 'yylex' function
#define YYLEX_PARAM	((SParserParam*)data)-&gt;scanner

#endif // __PARSERPARAM_H__
&lt;/source&gt;

The tokens needed by the bison parser will be generated using flex.

&lt;source lang=&quot;c&quot;&gt;
%{

/*
 * Lexer.l file
 * To generate the lexical analyzer run: &quot;flex --outfile=Lexer.c --header-file=Lexer.h Lexer.l&quot;
 */

#include &quot;TypeParser.h&quot;
#include &quot;Parser.h&quot;

%}

%option reentrant noyywrap never-interactive nounistd
%option bison-bridge

LPAREN      &quot;(&quot;
RPAREN      &quot;)&quot;
PLUS        &quot;+&quot;
MULTIPLY    &quot;*&quot;

NUMBER      [0-9]+
WS          [ \r\n\t]*

%%

{WS}            { /* Skip blanks. */ }
{NUMBER}        { sscanf(yytext,&quot;%d&quot;,&amp;yylval-&gt;value); return TOKEN_NUMBER; }

{MULTIPLY}      { return TOKEN_MULTIPLY; }
{PLUS}          { return TOKEN_PLUS; }
{LPAREN}        { return TOKEN_LPAREN; }
{RPAREN}        { return TOKEN_RPAREN; }
.               {  }

%%

int yyerror(const char *msg) { fprintf(stderr,&quot;Error:%s\n&quot;,msg); return 0; }
&lt;/source&gt;

The bison file providing describing the grammar of the numerical expressions.

&lt;source lang=&quot;c&quot;&gt;
%{

/*
 * Parser.y file
 * To generate the parser run: &quot;bison --defines=Parser.h Parser.y&quot;
 */

#include &quot;TypeParser.h&quot;
#include &quot;ParserParam.h&quot;

%}

%define api.pure

%left '+' TOKEN_PLUS
%left '*' TOKEN_MULTIPLY

%token TOKEN_LPAREN
%token TOKEN_RPAREN
%token TOKEN_PLUS
%token TOKEN_MULTIPLY

%token &lt;value&gt; TOKEN_NUMBER

%type &lt;expression&gt; expr

%%

input: 
	expr { ((SParserParam*)data)-&gt;expression = $1; }
	;

expr:
      expr TOKEN_PLUS expr { $$ = createOperation( ePLUS, $1, $3 ); }
    | expr TOKEN_MULTIPLY expr { $$ = createOperation( eMULTIPLY, $1, $3 ); }
    | TOKEN_LPAREN expr TOKEN_RPAREN { $$ = $2; }
    | TOKEN_NUMBER { $$ = createNumber($1); }
;
    
%%
&lt;/source&gt;

The code needed to obtain the syntax tree using the parser generated by bison and the scanner generated by flex is the following.

&lt;source lang=&quot;c&quot;&gt;
#include &quot;ParserParam.h&quot;
#include &quot;Parser.h&quot;
#include &quot;Lexer.h&quot;

#include &lt;stdio.h&gt;

int yyparse(void *param);

static int initParserParam(SParserParam* param)
{
	int ret = 0;

	ret = yylex_init(&amp;param-&gt;scanner);
	param-&gt;expression = NULL;

	return ret;
}

static int destroyParserParam(SParserParam* param)
{
	return yylex_destroy(param-&gt;scanner);
}

SExpression *getAST(const char *expr)
{
	SParserParam p;
	YY_BUFFER_STATE state;

	if ( initParserParam(&amp;p) )
	{
		// couldn't initialize
		return NULL;
	}

	state = yy_scan_string(expr, p.scanner);

	if ( yyparse(&amp;p) )
	{
		// error parsing
		return NULL;
	}

	yy_delete_buffer(state, p.scanner);

	destroyParserParam(&amp;p);

	return p.expression;
}

int evaluate(SExpression *e)
{
	switch(e-&gt;type)
	{
		case eVALUE:
			return e-&gt;value;
		case eMULTIPLY:
			return evaluate(e-&gt;left) * evaluate(e-&gt;right);
		case ePLUS:
			return evaluate(e-&gt;left) + evaluate(e-&gt;right);
		default:
			// shouldn't be here
			return 0;
	}
}

int main(void)
{
	SExpression *e = NULL;
	char test[]=&quot; 4 + 2*10 + 3*( 5 + 1 )&quot;;
	int result = 0;

	e = getAST(test);

	result = evaluate(e);

	printf(&quot;Result of '%s' is %d\n&quot;, test, result);

	deleteExpression(e);

	return 0;
}

&lt;/source&gt;

==Issues==
===Reentrancy===

Normally, Bison generates a parser which is not [[Reentrant (subroutine)|reentrant]]. In order to achieve reentrancy the declaration ''%define api.pure'' must be used. More details on Bison reentrancy can be found in the Bison manual.&lt;ref&gt;[http://www.gnu.org/software/bison/manual/bison.html#Pure-Decl GNU Bison Manual: A Pure (Reentrant) Parser]&lt;/ref&gt;

===Using bison from other languages===

Bison can only generate code for [[C (programming language)|C]], [[C++]] and [[Java (programming language)|Java]].&lt;ref&gt;[http://www.gnu.org/software/bison/manual/html_node/Decl-Summary.html GNU Bison Manual: Bison Declaration Summary]&lt;/ref&gt; For using the bison generated parser from other languages a [[language binding]] tool such as [[SWIG]] can be used.

==Where is it used?==

Here is a non-comprehensive list of software built using Bison:

* The [[Ruby_language|Ruby]] Programming Language (YARV);
* The [[PHP]] Programming Language (Zend Parser);
* [[GNU_Compiler_Collection|GCC]] started out using Bison, but switched to a hand-written parser in 2000&lt;ref&gt;[http://gcc.gnu.org/ml/gcc/2000-10/msg00573.html GCC drops YACC]&lt;/ref&gt;;
* The [[Go_(programming_language)|Go]] Programming Language (GC);
* [[Bash]] shell uses a yacc grammar for parsing the command input.  It is distributed with bison-generated files.

==References==
{{Reflist}}

==External links==
*[http://www.gnu.org/software/bison/ Website in the GNU Project]
**[http://www.gnu.org/software/bison/manual/ Manual]
*[http://savannah.gnu.org/projects/bison/ Project home at Savannah]
*[http://directory.fsf.org/bison.html Entry in the Free Software Directory]
*[http://cs.uic.edu/~spopuri/cparser.html Internals of C parsers generated by GNU Bison]
*[http://gnuwin32.sourceforge.net/packages/bison.htm Win32 binaries by GnuWin32] (version 2.4.1)

{{GNU}}

{{DEFAULTSORT:Gnu Bison}}
[[Category:GNU Project software|Bison]]
[[Category:Compiling tools]]
[[Category:Parser generators|Bison]]
[[Category:Cross-platform software]]

[[cs:GNU bison]]
[[da:GNU bison]]
[[de:GNU Bison]]
[[es:GNU Bison]]
[[fr:GNU Bison]]
[[ko:GNU bison]]
[[he:GNU bison]]
[[ja:Bison]]
[[pl:Bison (program)]]
[[pt:GNU bison]]
[[ru:GNU bison]]
[[sr:GNU bison]]
[[uk:GNU Bison]]
[[zh:GNU bison]]</rev></revisions></page></pages></query></api>
