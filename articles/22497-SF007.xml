<?xml version="1.0"?><api><query><pages><page pageid="22497" ns="0" title="OpenGL"><revisions><rev xml:space="preserve">{{Infobox software
|name = OpenGL
|logo = [[Image:OpenGL logo.jpg|OpenGL logo|220px]]
|author = [[Silicon Graphics]]
|developer = [[Khronos Group]]
|latest_release_version = 4.2&lt;ref&gt;[http://www.khronos.org/news/press/khronos-enriches-cross-platform-3d-graphics-with-release-of-opengl-4.2-spec Khronos Enriches Cross-Platform 3D Graphics with â¨Release of OpenGL 4.2 Specification]&lt;/ref&gt;
|latest_release_date = {{release date|2011|08|08}}
|programming_language = [[C (programming language)|C]]
|operating_system = [[Cross-platform]]
|platform = [[Cross-platform]]
|genre = [[Application programming interface|API]]
|license = Various&lt;ref&gt;http://www.sgi.com/products/software/opengl/license.html&lt;/ref&gt;
|website = [http://www.opengl.org/ www.opengl.org]
}}

'''OpenGL''' ('''Open G'''raphics '''L'''ibrary)&lt;ref&gt;http://www.opengl.org/registry/doc/glspec40.core.20100311.pdf OpenGL 4.0 Specification&lt;/ref&gt; is a standard specification defining a cross-language, [[cross-platform]] [[Application programming interface|API]] for writing applications that produce [[2D computer graphics|2D]] and [[3D computer graphics]]. The interface consists of over 250 different function calls which can be used to draw complex three-dimensional scenes from simple [[geometric primitive|primitives]]. OpenGL was developed by [[Silicon Graphics|Silicon Graphics Inc.]] (SGI) in 1992&lt;ref&gt;{{cite web|url=http://www.sgi.com/products/software/opengl/overview.html|title=SGI - OpenGL Overview}}&lt;/ref&gt; and is widely used in [[computer-aided design|CAD]], [[virtual reality]], scientific visualization, information visualization, [[Flight simulator|flight simulation]], and [[video game]]s. OpenGL is managed by the [[Non-profit organization|non-profit]] technology [[consortium]] [[Khronos Group]].

==Design==
OpenGL serves two main purposes, to:
# hide complexities of interfacing with different 3D accelerators by presenting a single, uniform interface
# hide differing capabilities of hardware platforms by requiring support of the full OpenGL feature set for all implementations (using software emulation if necessary)

In its basic operation, OpenGL accepts primitives such as points, lines and polygons, and converts them into pixels via a [[graphics pipeline]] known as the [http://www.opengl.org/documentation/specs/version1.1/state.pdf OpenGL state machine]. Most OpenGL commands either issue primitives to the graphics pipeline, or configure how the pipeline processes these primitives. Prior to the introduction of OpenGL 2.0, each stage of the pipeline performed a fixed function and was configurable only within tight limits. OpenGL 2.0 offers several stages that are fully programmable using [[GLSL]].

OpenGL is a low-level, procedural [[Application programming interface|API]], requiring the programmer to dictate the exact steps required to render a scene. This contrasts with descriptive (aka [[scene graph]] or [[retained mode]]) APIs, where a programmer only needs to describe a scene and can let the library manage the details of rendering it. OpenGL's low-level design requires programmers to have a good knowledge of the graphics pipeline, but also gives a certain amount of freedom to implement novel rendering algorithms.

OpenGL has historically been influential on the development of 3D accelerators, promoting a base level of functionality that is now common in consumer-level hardware:
[[Image:Pipeline OpenGL (en).png|thumb|right|430px|Simplified version of the Graphics Pipeline Process; excludes a number of features like blending, VBOs and logic ops]]
*[[Rasterisation|Rasterised]] points, lines and polygons as basic [[Geometric primitive|primitives]]
*A [[transform and lighting]] pipeline
*[[Z-buffering]]
*[[Texture mapping]]
*[[Alpha blending]]

A brief description of the process in the graphics pipeline could be:&lt;ref&gt;{{cite web|url= http://www.opengl.org/registry/doc/glspec21.20061201.pdf|format=PDF|title=The OpenGL Graphics System Specification. Version 2.1}}&lt;/ref&gt;
#Evaluation, if necessary, of the polynomial functions which define certain inputs, like [[Nonuniform rational B-spline|NURBS]] surfaces, approximating curves and the surface geometry.
#Vertex operations, transforming and lighting them depending on their material. Also clipping non-visible parts of the scene in order to produce the viewing volume.
#[[Rasterisation]] or conversion of the previous information into pixels. The polygons are represented by the appropriate colour by means of interpolation algorithms.
#Per-fragment operations, like updating values depending on incoming and previously stored depth values, or colour combinations, among others.
#Lastly, fragments are inserted into the [[Framebuffer|frame buffer]].

Many modern 3D accelerators provide functionality far above this baseline, but these new features are generally enhancements of this basic pipeline rather than radical revisions of it..

==Example==
This example will draw a green square on the screen. OpenGL has several ways to accomplish this task, but this is the easiest to understand. However, the reader should be aware that most of the APIs used in the code below have been deprecated in and after the OpenGL 3.0 specification.
{{Cleanup|section|date=September 2010}}

&lt;source lang=&quot;c&quot;&gt;
glClear( GL_COLOR_BUFFER_BIT );
&lt;/source&gt;
:This statement clears the color buffer, so that the screen will start blank. It takes an argument that defines which buffer to clear, in this case it is the color buffer.

&lt;source lang=&quot;c&quot;&gt;
glMatrixMode( GL_PROJECTION );      /* Subsequent matrix commands will affect the projection matrix */
glLoadIdentity();                   /* Initialise the projection matrix to identity */
glFrustum( -1, 1, -1, 1, 1, 1000 ); /* Apply a perspective-projection matrix */
&lt;/source&gt;
:These statements initialize the projection matrix, setting a 3d [[frustum]] matrix that represents the viewable area ([[viewing frustum]]). This matrix transforms objects from camera-relative space to OpenGL's projection space.

&lt;source lang=&quot;c&quot;&gt;
glMatrixMode( GL_MODELVIEW );       /* Subsequent matrix commands will affect the modelview matrix */
glLoadIdentity();                   /* Initialise the modelview to identity */
glTranslatef( 0, 0, -3 );           /* Translate the modelview 3 units along the Z axis */
&lt;/source&gt;
:These statements initialize the modelview matrix. This matrix defines a transform from model-relative coordinates to camera space. The combination of the modelview matrix and the projection matrix transforms objects from model-relative space to projection screen space.

&lt;source lang=&quot;c&quot;&gt;
glBegin( GL_POLYGON );              /* Begin issuing a polygon */
glColor3f( 0, 1, 0 );               /* Set the current color to green */
glVertex3f( -1, -1, 0 );            /* Issue a vertex */
glVertex3f( -1, 1, 0 );             /* Issue a vertex */
glVertex3f( 1, 1, 0 );              /* Issue a vertex */
glVertex3f( 1, -1, 0 );             /* Issue a vertex */
glEnd();                            /* Finish issuing the polygon */
&lt;/source&gt;
:These commands draw a green square in the XY plane. This is using [[immediate mode]]. The square could also be rendered using arrays and calling glDrawArrays(&amp;nbsp;).

==Documentation==
OpenGL's popularity is partially due to the quality of its official documentation. The OpenGL ARB released a series of manuals along with the specification which have been updated to track changes in the API. These are almost universally known by the colors of their covers:

;The Red Book
:OpenGL Programming Guide, 7th edition. ISBN 0-321-55262-8
:A readable tutorial and reference book â this is a 'must have' book for OpenGL programmers.
;The Blue Book
:OpenGL Reference manual, 4th edition. ISBN 0-321-17383-X
:Essentially a hard-copy printout of the [[Unix manual|man]] pages for OpenGL.
:Includes a poster-sized fold-out diagram showing the structure of an idealised OpenGL implementation.
;The Green Book
:OpenGL Programming for the X Window System. ISBN 0-201-48359-9
:A book about X11 interfacing and [[OpenGL Utility Toolkit|GLUT]].
;The Alpha Book (white cover)
:OpenGL Programming for Windows 95 and Windows NT. ISBN 0-201-40709-4
:A book about interfacing OpenGL with Microsoft Windows.

Then, for OpenGL 2.0 and beyond:

;The Orange Book
:OpenGL Shading Language, 3rd edition. ISBN 0-321-63763-1
:A readable tutorial and reference book for [[GLSL]].

==Extensions==
The OpenGL standard allows individual vendors to provide additional functionality through ''extensions'' as new technology is created. Extensions may introduce new functions and new constants, and may relax or remove restrictions on existing OpenGL functions. Each vendor has an alphabetic abbreviation that is used in naming their new functions and constants. For example, [[Nvidia]]'s abbreviation (''NV'') is used in defining their proprietary function &lt;code&gt;glCombinerParameterfvNV()&lt;/code&gt; and their constant &lt;code&gt;GL_NORMAL_MAP_NV&lt;/code&gt;.

It may happen that more than one vendor agrees to implement the same extended functionality. In that case, the abbreviation ''EXT'' is used. It may further happen that the Architecture Review Board &quot;blesses&quot; the extension. It then becomes known as a ''standard extension'', and the abbreviation ''ARB'' is used. The first ARB extension was &lt;code&gt;GL_ARB_multitexture&lt;/code&gt;, introduced in version 1.2.1. Following the official extension promotion path, multitexturing is no longer an optionally implemented ARB extension, but has been a part of the OpenGL core API since version 1.3.

Before using an extension a program must first determine its availability, and then obtain pointers to any new functions the extension defines. The mechanism for doing this is platform-specific and libraries such as [[OpenGL Extension Wrangler Library|GLEW]] and [[OpenGL Easy Extension library|GLEE]] exist to simplify the process.

Specifications for nearly all extensions can be found at the official extension registry.&lt;ref&gt;http://www.opengl.org/registry/&lt;/ref&gt;

==Associated utility libraries==
Several libraries are built on top of or beside OpenGL to provide features not available in OpenGL itself. Libraries such as [[OpenGL Utility Library|GLU]] can be found with most OpenGL implementations, and others such as [[OpenGL Utility Toolkit|GLUT]] and [[Simple DirectMedia Layer|SDL]] have grown over time and provide rudimentary cross-platform windowing and mouse functionality, and if unavailable can easily be downloaded and added to a development environment. Simple [[graphical user interface]] functionality can be found in libraries like [[OpenGL User Interface Library|GLUI]] or [[FLTK]]. Still other libraries like GLAux (OpenGL Auxiliary Library) are deprecated and have been superseded by functionality commonly available in more popular libraries, but code using them still exists, particularly in simple tutorials. Other libraries have been created to provide OpenGL application developers a simple means of managing OpenGL extensions and versioning. Examples of these libraries include [[OpenGL Extension Wrangler Library|GLEW]] (the OpenGL Extension Wrangler Library) and [[OpenGL Easy Extension library|GLEE]] (the OpenGL Easy Extension Library).

In addition to the aforementioned simple libraries, other higher-level object-oriented scene graph [[retained mode]] libraries exist such as [[PLIB]], [[OpenSG]], [[OpenSceneGraph]], and [[OpenGL Performer]]. These are available as cross-platform free/open source or [[Proprietary software|proprietary]] programming interfaces written on top of OpenGL and systems libraries to enable the creation of [[real-time computing|real-time]] visual simulation applications. Other solutions support parallel OpenGL programs for [[Virtual Reality]], scalability or graphics clusters usage, either transparently like [[Chromium (computer graphics)|Chromium]] or through a programming interface like [http://www.equalizergraphics.com/ Equalizer].

[[Mesa 3D]] is a free/open source implementation of OpenGL. It supports pure software rendering as well as providing hardware acceleration for several 3D graphics cards under [[Linux]]. As of 22 June 2007 it implements the 2.1 standard, and provides some of its own extensions for some platforms.

==Bindings==
{{Cleanup|section|date=July 2009}}
In order to emphasize its multi-language and multi-platform characteristics, various [[language binding|bindings]] and [[porting|ports]] have been developed for OpenGL in many languages. Some languages and their bindings are:
*[[Ada (programming language)|Ada]]: [http://adaopengl.sf.net/ AdaOpenGL 1.12] supports GL, GLU, GLUT, GLX and WGL  and (for OpenGL3) [http://sourceforge.net/projects/opengl3ada/ OpenGL3Ada]
*[[BlitzMax]]: Supplied OpenGL bindings included in its standard library.
*[[C Sharp (programming language)|C#]]:
**[http://www.opentk.com/ The Open Toolkit library] contains OpenGL, OpenAL and OpenCL bindings for .Net/Mono. Supports Win32/64, Linux and Mac OS X.
**The framework [[Tao Framework|Tao]] for [[.NET Framework|Microsoft .NET]] includes OpenGL between other multimedia libraries.&lt;ref&gt;http://www.taoframework.com/&lt;/ref&gt;
*[[D (programming language)|D]]: See [http://dsource.org/projects/bindings bindings] and [http://dsource.org/projects/derelict Project Derelict]
*[[Embarcadero Delphi|Delphi]]: [http://www.delphi3d.net/dot/ Dot]
*[[Eiffel (programming language)|Eiffel]]: [http://eifogl.sourceforge.net/ EiffelOpenGL] and [http://eiffelmedia.origo.ethz.ch/wiki/eiffelmedia Eiffelmedia]
*[[Fortran]]: [http://math.nist.gov/f90gl f90gl] supports OpenGL 1.2, GLU 1.2 and GLUT 3.7
*[[FreeBASIC]]: Native OpenGL support. Built-in OpenGL context creation.
*[[FreePascal]]: Supplied OpenGL bindings included in its standard distribution.
* [[Gambas]]: 2.x versions or later can utilize a component that can provide OpenGL acceleration.
*[[GLBasic]]: Powerful cross platform BASIC which uses OpenGL, [[OpenGL ES]] or a software rasterizer depending on the target platform.
*[http://www.complang.tuwien.ac.at/anton/lvas/stack-abgaben/07w/glforth/ GLforth]: an OpenGL engine written in Gforth.
*[[Haskell (programming language)|Haskell]]: [http://hackage.haskell.org/package/OpenGL HOpenGL] supports GL, GLU and GLUT. Currently included as part of [http://hackage.haskell.org/platform/ the Haskell Platform].
*[[Java (programming language)|Java]]:
**[[Java Bindings for OpenGL]] (JSR 231) and [[Java OpenGL]] (JOGL)
**[[Lightweight Java Game Library]] (LWJGL)
*[[Common Lisp]]: See [http://common-lisp.net/project/cl-opengl/ the cl-opengl project at common-lisp.net]
*[[Clojure]]: See [http://github.com/ztellman/penumbra Idiomatic OpenGL bindings for Clojure at github.com]
*[[Lazarus (IDE)|Lazarus]]: OpenGL context creation through LazOpenGLContext package. Real time 3D object manipulation though GLScene package.
*[[Lua (programming language)|Lua]]: See [http://lua-users.org/wiki/OpenGraphicsLibrary OpenGraphicsLibrary at lua-users wiki]
*[[Mercury (programming language)|Mercury]]: Prolog mtogl{{Where|date=July 2011}}
*[[Objective-C]]: Achieved by Cocoa classes NSOpenGLView, NSOpenGLContext and NSOpenGLPixelFormat.
*[[Objective Caml|Ocaml]]: [http://glcaml.sourceforge.net/ GLCaml], [http://wwwfun.kurims.kyoto-u.ac.jp/soft/lsl/lablgl.html LablGL] and [http://www.linux-nantes.org/~fmonnier/OCaml/GL/ glMLite]
*[[Perl]]:
**[[Perl OpenGL]] (POGL) module - shared libs written in C
**[http://graphcomp.com/opengl/benchmarks C vs Perl and Perl vs Python] benchmarks
*[[Pike (programming language)|Pike]]: It has a OpenGL native interface. Moreover, it supports GLU and GLUT&lt;ref&gt;http://pike.ida.liu.se/about/pike/modules.xml&lt;/ref&gt;
*[[PureBasic]]: Native OpenGL support.
*[[Python (programming language)|Python]]: [http://pyopengl.sourceforge.net/ PyOpenGL] supports GL, GLU and GLUT
*[[R (programming language)|R]]: [http://rgl.neoscientists.org/about.shtml rgl] package is a visualization device system using OpenGL as the rendering backend.
*[[Ruby (programming language)|Ruby]] [[Ruby MRI|MRI]]: [http://ruby-opengl.rubyforge.org/ ruby-opengl] - supports GL, GLU and GLUT
*[[Scheme (programming language)|Scheme]]:
**Chicken Scheme has a &lt;strike&gt;[http://www.call-with-current-continuation.org/eggs/opengl.html OpenGL egg]&lt;/strike&gt; [http://wiki.call-cc.org/gl-suite gl-suite] project
**[http://docs.racket-lang.org/sgl/ OpenGL bindings for Racket]
**[http://practical-scheme.net/gauche/packages.html OpenGL bindings for Gauche Scheme]
**[http://code.google.com/p/ypsilon/ Ypsilon Scheme] comes with GL and GLUT bindings out of the box
*[[Smalltalk]] as in [[Croquet Project]] running on Squeak Smalltalk
*[[thinBasic]]: native interface for OpenGL 2.1, GLU library + language specific higher level module
*[[Visual Basic]]: [http://www.weihenstephan.de/~syring/ActiveX/ ActiveX Control]
*[[Visual Prolog]] commercial edition
*[[WebGL]]: JavaScript binding to OpenGL ES 2.0 for web applications with hardware accelerated 3D graphics

==Higher level functionality==
OpenGL was designed to be graphic output-only: it provides only [[rendering (computer graphics)|rendering]] functions. The core API has no concept of [[windowing system]]s, audio, printing to the screen, keyboard/mouse or other [[input device]]s. While this seems restrictive at first, it allows the code that does the rendering to be completely independent of the [[operating system]] it is running on, allowing cross-platform development. However, some integration with the native windowing system is required to allow clean interaction with the host system. This is performed through the following add-on APIs:

*[[GLX]] â [[X Window System|X11]] (including [[network transparency]])
*[[WGL (software)|WGL]] â [[Microsoft Windows]]
*[[Core OpenGL|CGL]] â [[Mac OS X]]. Better integration with Mac OS X's application frameworks is provided by APIs layered on top of CGL: [[Apple Graphics Library|AGL]] for [[Carbon (API)|Carbon]] and [[NSOpenGL]] for [[Cocoa (API)|Cocoa]].

Additionally, the [[OpenGL Utility Toolkit|GLUT]], [[Simple DirectMedia Layer|SDL]], [http://www.sfml-dev.org/ SFML], and [http://www.glfw.org/ GLFW] libraries provide functionality for basic windowing using OpenGL, in a portable manner.

Some open source cross-platform toolkits, such as [[GTK+]], [[Qt (toolkit)|Qt]] and [[WxWidgets]], include widgets to embed OpenGL contents.

==History==
In the 1980s, developing software that could function with a wide range of graphics hardware was a real challenge. Software developers wrote custom interfaces and drivers for each piece of hardware. This was expensive and resulted in much duplication of effort.

By the early 1990s, [[Silicon Graphics]] (SGI) was a leader in 3D graphics for workstations. Their [[IRIS GL]] API&lt;ref&gt;{{cite web|url=http://www.cg.tuwien.ac.at/~wimmer/apis/API_Summary.html|title= IRIS GL, SGI's property}}&lt;/ref&gt; was considered state-of-the-art and became the de facto industry standard, overshadowing the open standards-based [[PHIGS]]. This was because IRIS GL was considered easier to use, and because it supported [[immediate mode]] rendering. By contrast, PHIGS was considered difficult to use and outdated in terms of functionality.

SGI's competitors (including [[Sun Microsystems]], [[Hewlett-Packard]] and [[IBM]]) were also able to bring to market 3D hardware, supported by extensions made to the PHIGS standard. This in turn caused SGI market share to weaken as more 3D graphics hardware suppliers entered the market. In an effort to influence the market, SGI decided to turn the IrisGL API into an open standard.

SGI considered that the IrisGL API itself was not suitable for opening due to licensing and patent issues. Also, the IrisGL had API functions that were not relevant to 3D graphics. For example, it included a windowing, keyboard and mouse API, in part because it was developed before the [[X Window System]] and Sun's [[NeWS]] systems were developed.

In addition, SGI had a large number of software customers; by changing to the OpenGL API they planned to keep their customers locked onto SGI (and IBM) hardware for a few years while market support for OpenGL matured. Meanwhile, SGI would continue to try to maintain their customers tied to SGI hardware by developing the advanced and proprietary [[Open Inventor|Iris Inventor]] and [[Iris Performer]] programming APIs.

As a result, SGI released the '''OpenGL''' standard.

OpenGL standardized access to hardware, pushed the development responsibility of hardware interface programs (sometimes called [[device driver]]s) to hardware manufacturers, and delegated windowing functions to the underlying operating system. With so many different kinds of graphics hardware, getting them all to speak the same language in this way had a remarkable impact by giving software developers a higher level platform for 3D-software development.

In 1992,&lt;ref&gt;{{cite web|url=http://www.sgi.com/company_info/newsroom/press_releases/2004/august/opengl.html|title=Creation of the OpenGL ARB}}&lt;/ref&gt; SGI led the creation of the OpenGL architectural review board (OpenGL ARB), the group of companies that would maintain and expand the OpenGL specification for years to come. OpenGL evolved from (and is very similar in style to) SGI's earlier 3D interface, ''IrisGL''. One of the restrictions of IrisGL was that it only provided access to features supported by the underlying hardware. If the graphics hardware did not support a feature, then the application could not use it. OpenGL overcame this problem by providing support in software for features unsupported by hardware, allowing applications to use advanced graphics on relatively low-powered systems.

In 1994, SGI played with the idea of releasing something called &quot;[[OpenGL++]]&quot; which included elements such as a scene-graph API (presumably based on their [[Performer (Computer Graphics API)|Performer]] technology). The specification was circulated among a few interested parties â but never turned into a product.&lt;ref&gt;{{cite web|url=http://www.opengl.org/about/arb/meeting_notes/notes/Meeting1.2/meeting_note_10-03-98.html|title=End of OpenGL++}}&lt;/ref&gt;

[[Microsoft]] released [[Direct3D]] in 1995, which eventually became the main competitor of OpenGL. On December 17, 1997,&lt;ref&gt;{{cite web|url=http://www.windowsitpro.com/Article/ArticleID/17533/17533.html|title=Announcement of Fahrenheit}}&lt;/ref&gt; Microsoft and SGI initiated the [[Fahrenheit graphics API|Fahrenheit]] project, which was a joint effort with the goal of unifying the OpenGL and Direct3D interfaces (and adding a scene-graph API too). In 1998, Hewlett-Packard joined the project.&lt;ref&gt;{{cite news|url=http://www.findarticles.com/p/articles/mi_m0CGN/is_n3341/ai_20211297| title=Members of Fahrenheit. 1998. | work=Computergram International | year=1998}}&lt;/ref&gt; It initially showed some promise of bringing order to the world of interactive 3D computer graphics APIs, but on account of financial constraints at SGI, strategic reasons at Microsoft, and general lack of industry support, it was abandoned in 1999.&lt;ref&gt;{{cite web|url=http://www.theregister.co.uk/1999/11/29/ms_quietly_dumps_windows_opengl/|title=End of Fahrenheit}}&lt;/ref&gt;

On the 31st July, 2006 it was announced at [[SIGGRAPH]] that control of the OpenGL specification would be passed to the Khronos group.&lt;ref&gt;[http://www.khronos.org/news/press/releases/opengl_arb_to_pass_control_of_opengl_specification_to_khronos_group/ OpenGL ARB to pass control of OpenGL specification to Khronos Group], Khronos press release&lt;/ref&gt;&lt;ref&gt;[http://www.accessmylibrary.com/coms2/summary_0286-16157838_ITM OpenGL ARB to Pass Control of OpenGL Specification to Khronos Group], AccessMyLibrary Archive&lt;/ref&gt;

===Releases===
OpenGL releases are backwards compatible. In general, graphics cards released after the OpenGL version release dates shown below support those version features, and all earlier features. For example the GeForce 6800, listed below, supports all features up to and including OpenGL 2.0 (specific cards may conform to an OpenGL specification, but selectively not support certain features. For details, the GPU Caps Viewer software includes a database of cards and their supported specifications).

===OpenGL 1.0===
Released in January 1992.&lt;br&gt;
The first OpenGL specification was released by Mark Segal and [[Kurt Akeley]].

====OpenGL 1.1====
Released in January 1997.&lt;br&gt;
OpenGL 1.1 focused on supporting textures and texture formats on GPU hardware.
&lt;br&gt;Supported GPU Cards: all

{| class=&quot;wikitable&quot;
|-
!Extension
!Extension ID
!Functions
|-
|Vertex Arrays
|EXT_vertex_array
|glVertexPointer, glColorPointer, glNormalPointer
|-
|Polygon Offsets (depth biasing)
|EXT_polygon_offset
|glPolygonOffset
|-
|RGBA logical blending
|EXT_blend_logic_op
|glBlendFunc
|-
|Texture Copy and Sub-copy
|EXT_subtexture, EXT_copy_texture
|glTexSubImage1D/2D/3D
|-
|Texture Formats
|EXT_texture
|RGB, LUMINANCE, ALPHA, INTENSITY (in glTexImage2D)
|-
|Texture Objects
|EXT_texture_object
|glGenTextures, glBindTextures
|}

====OpenGL 1.2====
Released on March 16, 1998.&lt;br&gt;
OpenGL 1.2 focused on supporting volume textures, packed pixels, normal rescaling, clamped/edge texture sampling and image processing.
&lt;br&gt;Supported GPU Cards: Rage 128, Rage 128 GL, Rage XL/XC, Rage 128 Pro, Rage Fury MAXX, GeForce2 MX, GeForce2 Ti, GeForce2 Pro,  and all later cards.

{| class=&quot;wikitable&quot;
|-
!Extension
!Extension ID
!Functions
|-
|3D Volume Textures
|GL_EXT_texture3D
|glTexImage3DEXT
|-
|BGRA Texture Format
|GL_EXT_bgra
|BGR_EXT, BGRA_EXT (in glTexImage2D)
|-
|Packed Pixels
|GL_EXT_packed_pixels
|
|-
|Normal Rescaling
|GL_EXT_rescale_normal
|
|-
|Separate Specular Color
|GL_EXT_separate_specular_color
|
|-
|Texture Coord Edge Clamping
|SGIS_texture_edge_clamp
|
|-
|Texture LOD Control
|SGIS_texture_lod
|
|-
|Draw Range Elements
|EXT_draw_range_elements
|glDrawRangeElements
|-
|Image Processing Subset
|EXT_color_table, EXT_convolution, SGI_color_matrix, EXT_histogram, EXT_blend_color, EXT_blend_minmax
|
|}

====OpenGL 1.2.1====
Released on October 14, 1998&lt;br&gt;
OpenGL 1.2.1 was a minor release after OpenGL 1.2 (March 16, 1998) which added multi-texture, or texture units, to the rendering pipeline. This allowed multiple textures to be blended per pixel during rasterization.
&lt;br&gt;Supported Cards: Radeon, Radeon Mobility, Radeon 7500 Mobility, Radeon 8500, Radeon 9000, Radeon 9200, Radeon 9600, Radeon 9800, GeForce 3, GeForce 4Ti, GeForce FX, and all later cards

{| class=&quot;wikitable&quot;
|-
!Extension
!Extension ID
!Functions
|-
|Multi-Texturing
|SGIS_multitexture
|glActiveTextureARB, glClientActiveTextureARB
|}

====OpenGL 1.3====
Released on August 14, 2001.&lt;br&gt;
OpenGL 1.3 added support for cubemap texture, multi-texturing, multi-sampling, and texture unit combine operations (add, combine, dot3, border clamp).
&lt;br&gt;Supported Cards: Radeon 32/36, Radeon 64/7200, Radeon 7000, Radeo AIW, Radeon 7500, Radeon IGP 320M, Radeon IGP 345M, ES1000, Radeon 8500, Radeon 9000/Pro, Radeon 9100/9200/9250 (Pro &amp; IGP), GeForce 3, GeForce 4Ti, GeForce FX, and all later cards.

{| class=&quot;wikitable&quot;
|-
!Extension
!Extension ID
!Functions
|-
|Compressed Textures
|GL_ARB_texture_compression
|
|-
|Cubemaps
|GL_EXT_texture_cube_map
|TEXTURE_CUBE_MAP_EXT
|-
|Multi-Sampling
|GL_ARB_multisample
|
|-
|Texture Add
|GL_ARB_texture_env_add
|
|-
|Texture Combine
|GL_ARB_texture_env_combine
|
|-
|Texture Dot3
|GL_ARB_texture_env_dot3
|
|-
|Texture Border Clamping
|GL_ARB_texture_border_clamp
|
|-
|Matrix Transpose
|GL_ARB_transpose_matrix
|
|}

====OpenGL 1.4====
Released on July 24, 2002.&lt;br&gt;
OpenGL 1.4 added hardware shadowing support, fog coordinates, automatic mipmap generation, and additional texture modes.
&lt;br&gt;Supported Cards: Quadro DCC, Quadro4 380 XGL, Quadro4 500XGL, 550XGL, Quadro4 700XGL, 750XGL, 900XGL, 980XGL, and all later cards.

{| class=&quot;wikitable&quot;
|-
!Extension
!Extension ID
!Functions
|-
|Automatic Mipmaps
|SGIS_generate_mipmap
|
|-
|Blend Squaring Functions
|GL_NV_blend_square
|
|-
|Depth Textures
|GL_ARB_depth_texture
|DEPTH_COMPONENT16/24/32_ARB
|-
|Hardware Shadowing Z-depth
|GL_ARB_shadow
|COMPARE_R_TO_TEXTURE
|-
|Fog Coordinates
|GL_EXT_fog_coord
|
|-
|Multiple Draw Arrays
|GL_EXT_multi_draw_arrays
|
|-
|Point Parameters
|GL_ARB_point_parameter
|
|-
|Secondary Color
|GL_EXT_secondary_color
|
|-
|Separate Blend Functions
|GL_EXT_blend_func_separate
|
|-
|Stencil Wrapping
|GL_EXT_stencil_wrap
|
|-
|Texture Crossbar Environment Mode
|GL_ARB_texture_env_crossbar
|
|-
|Texture LOD Bias
|GL_EXT_texture_lod_bias
|
|-
|Texture Mirrored Repeat
|GL_ARB_texture_mirrored_repeat
|
|-
|Window Raster Position
|GL_ARB_window_pos
|
|}

====OpenGL 1.5====
Released on July 29, 2003.&lt;br&gt;
OpenGL 1.5 added support for vertex buffer objects (VBOs), occlusion queries, and extended shadowing functions.
&lt;br&gt;Supported Cards: Radeon X800, Radeon 9600, Radeon 9700, Radeon 9800, GeForce FX, and all later cards.

{| class=&quot;wikitable&quot;
|-
!Extension
!Extension ID
!Functions
|-
|VBOs Vertex Buffer Objects
|GL_ARB_vertex_buffer_object
|glBindBufferARB, glBufferDataARB, glGenBuffersARB
|-
|Occlusion Queries
|GL_ARB_occlusion_query
|
|-
|Extended Shadow Functions
|GL_EXT_shadow_funcs
|
|}

===OpenGL 2.0===
Released on September 7, 2004.&lt;br&gt;

OpenGL 2.0 was originally conceived by [[3Dlabs]] to address concerns that OpenGL was stagnating and lacked a strong direction.&lt;ref&gt;{{cite web
| url=http://www.tomshardware.com/reviews/opengl-directx,2019-2.html
| title=OpenGL 3 (3DLabs And The Evolution Of OpenGL)
| author=Fedy Abi-Chahla
| publisher=[[Tom's Hardware]]
| date=2008-09-16
| accessdate=2010-10-24}}&lt;/ref&gt; 3Dlabs proposed a number of major additions to the standard. Most of these were, at the time, rejected by the ARB or otherwise never came to fruition in the form that 3Dlabs proposed. However, their proposal for a [[C (programming language)|C]]-style shading language was eventually completed, resulting in the current formulation of [[GLSL]] (the Open'''GL''' '''S'''hading '''L'''anguage, also '''sl'''ang). Like the assembly-like shading languages that it was replacing, it allowed the programmer to replace the fixed-function vertex and fragment pipe with [[shader (realtime, logical)|shaders]], though this time written in a C-like high-level language.

The design of GLSL was notable for making relatively few concessions to the limitations of the hardware then available; this hearkened back to the earlier tradition of OpenGL setting an ambitious, forward-looking target for 3D accelerators rather than merely tracking the state of currently available hardware. The final OpenGL 2.0 specification&lt;ref&gt;http://www.opengl.org/documentation/specs/version2.0/glspec20.pdf&lt;/ref&gt; includes support for GLSL.

OpenGL 2.0 added support for a true, GPU-based assembly language called [[ARB (GPU assembly language)|ARB]] (designed by the Architecture Review Board), which would become the standard for vertex and fragment shaders. Cards released with OpenGL 2.0 were the first to offer user-programmable shaders.&lt;ref&gt;Supported cards for OpenGL 2.0: Radeon 9650, Radeon 9500, Radeon 9500/9550/9600/9700/9800 (Pro, SE, XT), Radeon X1050, Radeon Xpress 200 / 1100, Radeon X300, Radeon X550, Radeon X600/Pro, Radeon X700, Radeon X800 (VE, SE, GT, Pro), Radeon X850, Radeon Xpress 1250, Radeon X1200, Radeon X1250, Radeon 2100, Radeon X1300, X1550, X1600, X1650, X1800, X1900, X1950 (Pro, XT, GT), GeForce 6800, Quadro 600, Qaudro FX 500, Quadro FX 700, Quadro FX 1000, FX 2000, FX 3000, Quadro FX 1400, Quadro FX 1500, Quadro FX 3450, Quadro FX 3500, Quadro FX 4500X2, Quadro FX4500 SDI, and all later cards. It is also included in Intel GMA X3500, X4500 and clarkdale family (core i3, core i5 inbuilt gpu chip on cpu) CPUs&lt;/ref&gt;

{| class=&quot;wikitable&quot;
|-
!Extension
!Extension ID
!Functions
|-
|Shader Objects
|GL_ARB_shader_objects
|
|-
|Vertex Programs
|GL_ARB_vertex_program
|glBindProgramARB, glGenProgramsARB
|-
|Vertex Shaders (VS)
|GL_ARB_vertex_shader
|
|-
|Fragment Shaders (FS)
|GL_ARB_fragment_shader
|
|-
|Multiple Render Targets
|GL_ARB_draw_buffers
|glDrawBuffers
|-
|Non-power-of-two Texture
|GL_ARB_texture_non_power_of_two

|-
|Point Sprites
|GL_ARB_point_sprite
|
|-
|Multiple Render Targets
|GL_ARB_draw_buffers
|not truly &quot;multiple&quot; on ATI cards at that time (GL_MAX_DRAW_BUFFERS=1)
|-
|Vertex texture fetch
|
|not truly supported on ATI cards at that time (GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS=0)
|-
|Separate Blend Equation
|GL_EXT_blend_equation_separate
|
|-
|Separate Stencil
|GL_EXT_stencil_two_side
|
|}

====OpenGL 2.1====
Released on July 2, 2006.&lt;br&gt;
OpenGL 2.1 introduced support for pixel buffer objects (PBOs), sRGB textures (gamma-corrected textures), and non-square matrices, and the Shading Language revision GLSL 1.20.&lt;ref&gt;{{cite web|url =http://de.planet64bit.de/node/1869 | title=OpenGL 2.1 Features}}&lt;/ref&gt;
&lt;br&gt;Supported Cards: [[Intel HD Graphics]], Intel HD Graphics 2000/3000 Radeon HD 2350, GeForce FX (with late drivers), GeForce 6 series, GeForce 7 series, GeForce Go 7 series, Quadro FX 4000, Quadro FX 350, Quadro FX 550, Quadro FX 560, Quadro FX 1400, Quadro FX 1500, Quadro FX 5500, and all later cards.

{| class=&quot;wikitable&quot;
|-
!Extension
!Extension ID
!Functions
|-
|Non-Square Matricies
|
|glUniformMatrix{}fv
|-
|PBOs Pixel Buffer Objects
|GL_ARB_pixel_buffer_object
|
|-
|sRGB Texture (gamma 2.2)
|GL_EXT_texture_sRGB
|
|}

===Longs Peak and OpenGL 3.0 controversy===
Prior to the release of OpenGL 3.0, the new revision was known as the codename [[Longs Peak]]. At the time of its original announcement, Longs Peak was presented as the first major API revision in OpenGL's lifetime. It consisted of an overhaul to the way that OpenGL works, calling for fundamental changes to the API.

The draft introduced a change to object management. The GL 2.1 object model was built upon the state-based design of OpenGL. That is, in order to modify an object or to use it, one needs to bind the object to the state system, then make modifications to the state or perform function calls that use the bound object.

Because of OpenGL's use of a state system, objects must be mutable. That is, the basic structure of an object can change at any time, even if the rendering pipeline is asynchronously using that object. A texture object can be redefined from 2D to 3D. This requires any OpenGL implementations to add a degree of complexity to internal object management.

Under the Longs Peak API, object creation would become atomic, using templates to define the properties of an object which would be created with a single function call. The object could then be used immediately across multiple threads. Objects would also be immutable; however, they could have their contents changed and updated. For example, a texture could change its image, but its size and format could not be changed.

To support backwards compatibility, the old state based API would still be available, but no new functionality would be exposed via the old API in later versions of OpenGL. This would have allowed legacy code bases, such as the majority of [[Computer-aided design|CAD]] products, to continue to run while other software could be written against or ported to the new API.

Longs Peak was initially due to be finalized in September 2007 under the name OpenGL 3.0, but the Khronos group announced on October 30 that it had run into several issues that it wished to address before releasing the specification.&lt;ref&gt;{{cite web|url=http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&amp;Number=229374#Post229374|title=OpenGL ARB announces an update on OpenGL 3.0|date=October 30, 2007|accessdate=2007-10-31}}&lt;/ref&gt; As a result, the spec was delayed, and the Khronos group went into a [[media blackout]] until the release of the final OpenGL 3.0 spec.

The final specification proved far less revolutionary than the Longs Peak proposal. Instead of removing all immediate mode and fixed functionality (non-shader mode), the spec included them as deprecated features. The proposed object model was not included, and no plans have been announced to include it in any future revisions. As a result, the API remained largely the same with a few existing extensions being promoted to core functionality.

Among some developer groups this decision caused something of an uproar,&lt;ref&gt;http://tech.slashdot.org/article.pl?sid=08/08/11/2135259&lt;/ref&gt; with many developers professing that they would switch to [[DirectX]] in protest. Most complaints revolved around the lack of communication by Khronos to the development community and multiple features being discarded that were viewed favorably by many. Other frustrations included the requirement of DirectX 10 level hardware in order to use OpenGL 3.0 and the absence of geometry shaders and instanced rendering as core features.

Other sources reported that the community reaction was not quite as severe as originally presented,&lt;ref&gt;{{cite web|url=http://www.opengl.org/news/opengl_bof_went_over_well_no_pitch_forks_seen|title=OpenGL BOF went over well, no pitch forks seen}}&lt;/ref&gt; with many vendors showing support for the update.&lt;ref&gt;http://www.opengl.org/news/nick_haemel_amd_blog_post_opengl_30_a_big_step_in_the_right_direction/&lt;/ref&gt;&lt;ref&gt;{{cite web|url=http://www.opengl.org/news/nvidia_provides_early_opengl_30_driver_now|title=NVIDIA provides early OpenGL 3.0 driver now}}&lt;/ref&gt;

===OpenGL 3.0===
Released on July 11, 2008.&lt;br&gt;
OpenGL 3.0 added support for frame buffer objects, hardware instancing, vertex array objects (VAOs), and sRGB framebuffers (gamma 2.2).&lt;ref&gt;http://www.opengl.org/registry/doc/glspec30.20080811.pdf&lt;/ref&gt; OpenGL 3.0 introduced a deprecation mechanism to simplify the API in future revisions.
&lt;br&gt;Supported Cards: Radeon HD series; GeForce 8, 9, 100-series, 200-series, 300-series, 400-series and 500-series; Intel Sandy Bridge HD Graphics 2000 and 3000.

Features:
*OpenGL Shading Language revision 1.30 ([[GLSL]])
*Vertex Array Objects
*More flexible Framebuffer Objects
*32-bit ([[single precision]]) floating-point textures and render buffers
*16-bit ([[half precision]]) floating-point vertex and pixel data
*Ability to render vertex transformations into a buffer
*Texture arrays
*32-bit (single precision) floating point depth buffer support

Full use of OpenGL 3.0 requires the same level of hardware as is required for DirectX 10 support. Unlike DirectX 10, OpenGL 3.0 does not require Windows Vista and can be used on any OS for which the appropriate drivers are provided.

{| class=&quot;wikitable&quot;
|-
!Extension
!Extension ID
!Functions
|-
|FBOs Frame Buffer Objects
|GL_EXT_framebuffer_object
|glFrameBufferTexture2DEXT
|-
|FBO Multisampling
|GL_EXT_framebuffer_multisample
|
|-
|Hardware Instancing
|GL_EXT_draw_instanced
|glDrawArraysInstancedEXT, glDrawElementsInstancedEXT
|-
|VAOs Vertex Array Objects
|GL_ARB_vertex_array_object
|glBindVertexArray, glGenVertexArray
|-
|sRGB Framebuffers (gamma 2.2)
|GL_EXT_framebuffer_sRGB
|FRAMEBUFFER_SRGB_EXT
|-
|Transform Feedback
|GL_EXT_transform_feedback
|glBeginTransformFeedback, glBeginTransformFeedback, glBindBufferRange, glTransformFeedbackVaryings
|}

Note that Transform feedback in OpenGL 3.0 is ''not'' modelled after NV_transform_feedback, which means that a program ''must'' be (re-)linked after calling glTransformFeedbackVaryings.

====OpenGL 3.1====
Released on March 24, 2009 and updated on May 28, 2009.&lt;br&gt;
OpenGL 3.1 introduces a range of features to make the API more convenient to use, in addition to performance oriented features:&lt;ref&gt;{{cite press release|url=http://www.khronos.org/news/press/releases/khronos-releases-streamlined-opengl-3.1-specification/|title=Khronos Releases Streamlined OpenGL 3.1 Specification|date=24 March 2009|publisher=[[Khronos Group]]|accessdate=2009-03-30}}&lt;/ref&gt;

*OpenGL Shading Language revision 1.40 ([[GLSL]])
*Texture Buffer Objects - a new texture type that holds a one-dimensional array of [[texel (graphics)|texels]]
*Uniform Buffer Objects for fast data share/update
*Signed normalized textures (Â±1.0 range)
*A minimum of 16 texture units accessible by the vertex shader
*Primitive restart
*Instancing - drawing of objects multiple times through the re-use of vertex data
*CopyBuffer API for fast data copy; used in conjunction with [[OpenCL]]
*Rectangular textures

With the release of the OpenGL 3.1 specification, a compatibility extension was also released that enables developers to access the OpenGL 1.X/2.X functionality removed in OpenGL 3.1.&lt;ref&gt;{{cite web| url=http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&amp;Number=255002|title= Official feedback on OpenGL 3.1 thread|work=OpenGL.org Discussion and Help Forums|author=Khronos webmaster|date=March 24, 2009|accessdate=2009-03-30}}&lt;/ref&gt; Notably, legacy functionality for wide line support is retained.

Removed legacy functionality includes:&lt;ref&gt;{{cite web|url=http://www.h-online.com/open/news/item/Specification-adopted-for-OpenGL-3-1-740766.html|title=Specification adopted for OpenGL 3.1|date=25 March 2009|first=Manfred|last= Bertuch|publisher=[[heise online]]|accessdate=2011-01-04}}&lt;/ref&gt;

*All fixed-function options
*Direct mode
*[[indexed color|Color index mode]], i.e. pixel formats with color palettes

====OpenGL 3.2====
Released on August 3, 2009 and updated on December 7, 2009.&lt;br&gt;
Supported Cards: GeForce 8, GeForce 9, GeForce 100, GeForce 200 and GeForce 300 series, Radeon HD series

Features:
*OpenGL Shading Language revision 1.50 ([[GLSL]])
*Geometry Shader support
*BGRA vertex component ordering
*Shader Fragment coordinate convention control
*Seamless cube map filtering
*Fragment depth clamping
*Multisampled textures and texture samples for specific sample locations
*Sync and Fence objects

====OpenGL 3.3====
Released on March 11, 2010&lt;br&gt;
Supported Cards: GeForce 8, GeForce 9, GeForce 100, GeForce 200 and GeForce 300 series, Radeon HD series

OpenGL 3.3, simultaneously released with OpenGL 4.0 and supplemented by a set of new [[OpenGL_Architecture_Review_Board|ARB]] extensions, backports as much functionality as possible from the OpenGL 4.0 specification for use on previous generation [[GPU]] hardware. Includes GLSL 3.30.

===OpenGL 4.0===
Released on March 11, 2010&lt;br&gt;
Supported Cards: [[GeForce 400 Series|Nvidia GeForce 400 series]], [[GeForce 500 Series|Nvidia GeForce 500 series]], [[Radeon HD 5000 series|ATI Radeon HD 5000 series]], [[Northern Islands (GPU family)|AMD Radeon HD 6000 Series]]

Features:&lt;ref&gt;{{cite web|url=http://www.khronos.org/news/press/releases/khronos-unleashes-cutting-edge-cross-platform-graphics-acceleration-opengl4|title=Khronos Unleashes Cutting-Edge, Cross-Platform Graphics Acceleration with OpenGL 4.0|work=Khronos Press Releases|author=Khronos webmaster |date=March 11, 2010|accessdate=2010-03-11}}&lt;/ref&gt;

*OpenGL Shading Language revision 4.00 ([[GLSL]])
*Two new shader stages that enable the GPU to offload geometry tessellation from the CPU.
*Per-sample fragment shaders and programmable fragment shader input positions for increased rendering quality and anti-aliasing flexibility.
*Shader subroutines for significantly increased programming flexibility.
*Separation of texture state and texture data through the addition of a new object type called sampler objects.
*Drawing of data generated by OpenGL or external APIs such as [[OpenCL]], without CPU intervention.
*64-bit double precision floating point shader operations and inputs/outputs for increased rendering accuracy and quality.
*Performance improvements; such as instanced geometry shaders, instanced arrays and a new timer query.

====OpenGL 4.1====
Released on 26 July 2010&lt;ref&gt;{{cite web|url=http://www.extremetech.com/article2/0,2845,2366981,00.asp|title=OpenGL 4.1 Specification Released}}&lt;/ref&gt; &lt;br&gt;
Supported Cards: [[GeForce 400 Series|Nvidia GeForce 400 series]], [[GeForce 500 Series|Nvidia GeForce 500 series]], [[Radeon HD 5000 series|ATI Radeon HD 5000 series]], [[Northern Islands (GPU family)|AMD Radeon HD 6000 Series]]

This new version adds these additional features to the specification, many of which help bring it in line with those in Direct3D 11:
* OpenGL Shading language (GLSL) 4.1
* Full compatibility with [[OpenGL ES|OpenGL for Embedded Systems]] (OpenGL ES) 2.0 APIs
* Reduced shaders compilation times with the ability to query and load a binary for shader program objects
* The ability to bind programs individually to the five programmable stages (Vertex, Tessellation Control, Tessellation Evaluation, Geometry, and Fragment)
* Improvements to the general 64-bit floating point supported added in OpenGL 4.0 (64-bit floating-point component input for vertex shader)

====OpenGL 4.2====
Released on 8 August 2011&lt;ref&gt;{{cite web|url=http://www.khronos.org/news/press/khronos-enriches-cross-platform-3d-graphics-with-release-of-opengl-4.2-spec|title=Khronos Enriches Cross-Platform 3D Graphics with â¨Release of OpenGL 4.2 Specification}}&lt;/ref&gt; &lt;br&gt;
Supported Cards: [[GeForce 400 Series|Nvidia GeForce 400 series]], [[GeForce 500 Series|Nvidia GeForce 500 series]], [[Radeon HD 5000 series|ATI Radeon HD 5000 series]], [[Northern Islands (GPU family)|AMD Radeon HD 6000 Series]]

* Support for shaders with atomic counters and load/store/atomic read-modify-write operations to a single level of a texture.
* Capturing GPU-tessellated geometry and drawing multiple instances of the result of a transform feedback to enable complex objects to be efficiently repositioned and replicated.
* Support for modifying an arbitrary subset of a compressed texture, without having to re-download the whole texture to the GPU for significant performance improvements.
* Support for packing multiple 8 and 16 bit values into a single 32-bit value for efficient shader processing with significantly reduced memory storage and bandwidth.

==Sample renderings==
&lt;center&gt;
&lt;gallery&gt;
Image:JOGL Refrection Demo Screenshot.png|Refraction using programmable vertex shaders
Image:Perl OpenGL fob2.jpg|Animated textures using framebuffer objects and vertex/fragment program extensions
Image:Synth_video_game_screenshot_C.png|Procedural artwork using display lists
&lt;/gallery&gt;
&lt;/center&gt;

==See also==
*[[List of OpenGL programs]] â list of popular games and applications that use OpenGL
*[[ARB (GPU assembly language)]] â OpenGL's low-level shading language
*[[Cg (programming language)|Cg]] â Nvidia's shading language that works with OpenGL
*[[GLSL]] â Open crossplatform high-level shading language that works with OpenGL
*[[OpenCL]] â Open crossplatform GPU general purpose language that works with OpenGL
*[[OpenGL ES]] â OpenGL for embedded systems
*[[OpenVG]] â 2D vector graphics API aiming to leverage accelerated-hardware
*[[OpenAL]] â The Open Audio Library â designed to work well with OpenGL
*[[OpenSL ES]] â Another audio library
*[[OpenML]] â The Open Media Library â designed to work well with OpenGL
*[[Graphics pipeline]]
*[[Vertex Buffer Object]]

===OpenGL support libraries===
*[[OpenGL Utility Library|GLU]] â Some additional functions for OpenGL programs.
*[[OpenGL Utility Toolkit|GLUT]] â The OpenGL utility toolkit.
*[[freeglut]] â [[Open source]] alternative to GLUT
*[[OpenGL User Interface Library|GLUI]] â a [[Graphical user interface|GUI]] toolkit made with GLUT
*[[Simple DirectMedia Layer|SDL]] â The Simple DirectMedia Layer.
*[[OpenGL Easy Extension library|GLee]] â The OpenGL Easy Extension library.
*[[OpenGL Extension Wrangler Library|GLEW]] â The OpenGL Extension Wrangler Library.
*[[OpenGL Mathematics|GLM]] â C++ mathematics toolkit for OpenGL based on the GLSL specification.
*SFML â Simple and Fast Multimedia Library.
*[[JOGL]] â Java bindings for OpenGL API.

===Other 3D graphics APIs===
*[[Direct3D]] â A competitor to OpenGL. See [[Comparison of OpenGL and Direct3D]].
*[[Glide API|Glide]] â A graphics API for use on [[3dfx Interactive|3dfx]] Voodoo cards.
*[[Mesa 3D]] â An open source implementation of OpenGL.
* [[Open Inventor]] - C++ object oriented 3D graphics API that provides a higher layer of programming for OpenGL.
*[[RenderMan Interface Specification|RISpec]] â [[Pixar]]'s open API for photorealistic off-line rendering.
*[[VirtualGL]] â An OpenGL 3D model server that sends rendered images to a remote X server.

===Other 2D graphics APIs===
*[[Cairo (graphics)|cairo]] â a cross platform graphical vectorial draw and text toolkit.
*[[GTK+]] â a cross platform graphical widget toolkit.
*[[Java 2D]] â a cross platform API for drawing two-dimensional graphics.
*[[Qt (toolkit)|Qt]] â a cross platform graphical widget toolkit.
*[[wxWidgets]] â a cross platform graphical widget toolkit.
*[[Asymptote_(vector_graphics_language)|Asymptote Vector Graphics Language]] â a script driven, [[LaTex]] compatible, language for high quality sketches, graphs, diagrams, geometry and typesetting with output in [[PostScript]], [[PDF]], [[SVG]], and 3D [[PRC_(File_format)|PRC]].

==References==
{{Reflist|2}}

==Books==
*Richard S. Wright, Benjamin Lipchak, Nicholas Haemel, Graham Sellers: ''OpenGL SuperBible: Comprehensive Tutorial and Reference, 5th Edition'', Addison-Wesley, July 23, 2010, ISBN 978-0321712615
*Dave Shreiner, The Khronos OpenGL ARB Working Group: ''OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 3.0 and 3.1, 7th Edition'', Addison-Wesley, July 21, 2009, ISBN 978-0321552624
*Fosner, Ron: ''OpenGL Programming for Windows 95 and Windows NT'', Addison Wesley, ISBN 0-201-40709-4
*[[Mark Kilgard|Kilgard, Mark]]: ''OpenGL for the X Window System'', Addison-Wesley, ISBN 0-201-48359-9
*[[Eric Lengyel|Lengyel, Eric]]: ''The OpenGL Extensions Guide'', Charles River Media, ISBN 1-58450-294-0
*[[OpenGL Architecture Review Board]], et al.: ''OpenGL Reference Manual: The Official Reference Document to OpenGL, Version 1.4'', Addison-Wesley, ISBN 0-321-17383-X
*[[OpenGL Architecture Review Board]], et al.: ''OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 2, Fifth Edition'', Addison-Wesley, ISBN 0-321-33573-2
*[[Rost, Randi J.]]: ''OpenGL Shading Language'', Addison-Wesley, ISBN 0-321-19789-5

==External links==
{{wikibooks|Programming:OpenGL}}
*[http://www.opengl.org/ Official website]
*[http://www.opengl.org/wiki/Language_bindings OpenGL.org's Wiki] more information on OpenGL Language bindings
*[http://www.sgi.com/products/software/opengl/ SGI's OpenGL website]
*{{dmoz|Computers/Programming/Graphics/Libraries/OpenGL|OpenGL}}
*[http://www.khronos.org/ Khronos Group, Inc.]

{{Khronos Group standards}}

{{DEFAULTSORT:Opengl}}
[[Category:OpenGL]]
[[Category:Graphics libraries]]
[[Category:Application programming interfaces]]
[[Category:Video game development]]
[[Category:Graphics standards]]
[[Category:Virtual reality]]
[[Category:Cross-platform software]]

{{Link GA|lv}}

[[ar:ÙÙØªØ¨Ø© Ø§ÙØ±Ø³ÙÙÙØ§Øª Ø§ÙÙÙØªÙØ­Ø©]]
[[bn:à¦à¦ªà§à¦¨à¦à¦¿à¦à¦²]]
[[bg:OpenGL]]
[[bs:OpenGL]]
[[ca:OpenGL]]
[[cs:OpenGL]]
[[da:OpenGL]]
[[de:OpenGL]]
[[et:OpenGL]]
[[es:OpenGL]]
[[fa:Ø§Ù¾ÙâØ¬ÛâØ§Ù]]
[[fr:OpenGL]]
[[gl:OpenGL]]
[[ko:OpenGL]]
[[id:OpenGL]]
[[it:OpenGL]]
[[he:OpenGL]]
[[ka:OpenGL]]
[[lv:OpenGL]]
[[hu:OpenGL]]
[[mk:OpenGL]]
[[ml:à´à´ªàµà´ªàµºà´à´¿âà´àµ½]]
[[mr:à¤à¤ªà¤¨à¤à¥à¤à¤²]]
[[ms:OpenGL]]
[[nl:OpenGL]]
[[ja:OpenGL]]
[[no:OpenGL]]
[[pl:OpenGL]]
[[pt:OpenGL]]
[[ro:OpenGL]]
[[ru:OpenGL]]
[[simple:OpenGL]]
[[sk:OpenGL]]
[[sl:OpenGL]]
[[sr:OpenGL]]
[[fi:OpenGL]]
[[sv:OpenGL]]
[[th:à¹à¸­à¹à¸à¸à¸à¸µà¹à¸­à¸¥]]
[[tr:OpenGL]]
[[uk:OpenGL]]
[[vi:OpenGL]]
[[zh:OpenGL]]</rev></revisions></page></pages></query></api>
