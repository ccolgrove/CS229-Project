<?xml version="1.0"?><api><query><pages><page pageid="16389" ns="0" title="Java Virtual Machine"><revisions><rev xml:space="preserve">[[File:Java virtual machine architecture.svg|thumb|400px|Overview of a Java virtual machine (JVM) architecture. Source code is compiled to Java bytecode, which is verified, interpreted or JIT-compiled for the native architecture. The Java APIs and JVM together make up the Java Runtime Environment (JRE).]]
A '''Java virtual machine''' ('''JVM''') is a [[virtual machine]] capable of executing [[Java bytecode]]. It is the code execution component of the [[Java (software platform) | Java software platform]]. [[Sun Microsystems]] stated that there are over 4.5 billion JVM-enabled devices.&lt;ref&gt;http://www.java.com/en/about/ Learn about Java Technology&lt;/ref&gt;

==Overview==
A Java virtual machine is software that is implemented on non-virtual hardware and on standard [[operating system]]s. A JVM provides an environment in which Java bytecode can be executed, enabling such features as [[automated exception handling]], which provides &quot;root-cause&quot; debugging information for every software error ([[exception handling|exception]]), independent of the source code. A JVM is distributed along with a [[Java Class Library|set of standard class libraries]] that implement the Java [[application programming interface]] (API). Appropriate APIs bundled together with JVM form the Java Runtime Environment (JRE).

JVMs are available for many hardware and software [[platform (computing)|platforms]]. The use of the same bytecode for all JVMs on all platforms allows Java to be described as a &quot;[[write once, run anywhere]]&quot; programming language, as opposed to &quot;[[write once, compile anywhere]]&quot;, which describes cross-platform [[compiled language]]s. Thus, the JVM is a crucial component of the [[Java (software platform)|Java platform]].

Java bytecode is an [[intermediate language]] which is typically compiled from Java, but it can also be compiled from other programming languages. For example, [[Ada (programming language)|Ada]] source code can be compiled to Java bytecode and executed on a JVM.

[[Oracle Corporation|Oracle]], the owner of Java, produces a JVM, but JVMs using the &quot;Java&quot; trademark may be developed by other companies as long as they adhere to the JVM specification published by Oracle and to related contractual obligations.

The Oracle JVM (HotSpot) is written in the [[C++ (programming language)|C++ programming language]].&lt;ref&gt; http://openjdk.java.net/groups/hotspot/ &lt;/ref&gt;

== Execution environment ==
Sun Microsystem's Java execution environment is termed the Java Runtime Environment, or JRE.

Programs intended to run on a JVM must be compiled into a standardized portable binary format, which typically comes in the form of [[class (file format)|.class]] files. A program may consist of many classes in different files. For easier distribution of large programs, multiple class files may be packaged together in a [[jar (file format)|.jar]] file (short for Java archive).

The Java application launcher, &lt;code&gt;java&lt;/code&gt;, offers a standard way of executing Java code. Compare &lt;code&gt;javaw&lt;/code&gt;.&lt;ref&gt;
{{cite web
| url         = http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=/com.ibm.rt.doc.20/user/java.html
| title       = The java and javaw commands
| year        = 2010
| publisher   = IBM
| accessdate  = 2011-01-16
| quote       = The javaw command is identical to java, except that javaw has no associated console window.
}}
&lt;/ref&gt;

The JVM [[run-time system|runtime]] executes &lt;tt&gt;.class&lt;/tt&gt; or &lt;tt&gt;.jar&lt;/tt&gt; files, [[emulator|emulating]] the JVM [[instruction set]] by [[interpreter (computing)|interpreting]] it, or using a [[just-in-time compilation|just-in-time compiler]] (JIT) such as Oracle's [[HotSpot (Java)|HotSpot]]. JIT compiling, not interpreting, is used in most JVMs today to achieve greater speed. There are also [[AOT compiler|ahead-of-time compilers]] that enable developers to precompile class files into native code for particular platforms.

Like most virtual machines, the Java virtual machine has a [[stack machine|stack]]-based architecture akin to a microcontroller/microprocessor.  However, the JVM also has low-level support for Java-like classes and methods, which amounts to a highly idiosyncratic{{clarify|date=October 2010}} [[Java Memory Model|memory model]] and capability-based architecture.

==JVM languages==
{| class=&quot;wikitable&quot; align=&quot;left&quot;
|+Versions of non-JVM languages
!Language!!On JVM
|-
|[[Erlang (programming language)|Erlang]]||[[Erjang]]
|-
|[[JavaScript]]||[[Rhino (JavaScript engine)|Rhino]]
|-
|[[Pascal (programming language)|Pascal]]||[[Free Pascal]]
|-
|[[PHP]] ||[[Resin Server|Resin]]
|-
|[[Python (programming language)|Python]]||[[Jython]]
|-
|[[REXX]]||[[NetRexx]]&lt;ref&gt;1996, possibly the first new language specifically designed to run on the JVM)&lt;/ref&gt;
|-
|[[Ruby (programming language)|Ruby]]||[[JRuby]]
|-
|[[Tcl]] ||[[Tcl/Java#Jacl|Jacl]]
|}
{| class=&quot;wikitable&quot; align=&quot;right&quot;
|+Languages designed expressly for JVM
|-
|[[MIDletPascal]]
|-
|[[Clojure]]
|-
|[[Groovy (programming language)|Groovy]]
|-
|[[Scala (programming language)|Scala]]
|-
|[[Fantom (programming language)|Fantom]]
|-
|[[BBj]]
|}
{{See also|Da Vinci Machine|List of JVM languages}}
Although the JVM was primarily aimed at running compiled Java programs, many other languages can now run on top of it.&lt;ref&gt;{{cite web|url = http://www.is-research.de/info/vmlanguages/|title = Languages for the Java VM|last = Tolksdorf|first = Robert|year = 2005|accessdate = 2008-06-08}}&lt;/ref&gt;
The JVM has currently no built-in support for [[type system#Dynamic typing|dynamically typed languages]]: the existing [[Java bytecode|JVM instruction set]] is [[type system#Static typing|statically typed]],&lt;ref&gt;{{cite web | url=http://headius.blogspot.com/2007/01/invokedynamic-actually-useful.html | title=InvokeDynamic: Actually Useful? | date=2007-01-03 |last=Nutter|first=Charles | accessdate=2008-01-25}}&lt;/ref&gt; although the JVM can be used to implement interpreters for dynamic languages. Prior to [[Java_version_history#Java SE 7.0|Java 7]] the JVM had a limited support for [[hotswapping#Software|dynamically modifying]] existing classes and methods; this only worked in a [[Java Platform Debugger Architecture|debugging environment]], where new classes and methods can be added dynamically.
Better support for dynamic languages is included in JVM since [[Java_version_history#Java SE 7.0|Java 7]].&lt;ref&gt;{{cite web | url = http://www.infoworld.com/article/08/01/31/davinci-machine_1.html | title=Sun's Da Vinci Machine broadens JVM coverage | last = Krill | first=Paul | date=2008-01-31 | accessdate=2008-02-06}}&lt;/ref&gt;

== Bytecode verifier ==

A basic philosophy of Java is that it is inherently &quot;safe&quot; from the standpoint that no user program can &quot;crash&quot; the host machine or otherwise interfere inappropriately with other operations on the host machine, and that it is possible to protect certain methods and data structures belonging to &quot;trusted&quot; code from access or corruption by &quot;untrusted&quot; code executing within the same JVM. Furthermore, common programmer errors that often lead to data corruption or unpredictable behavior such as accessing off the end of an array or using an uninitialized pointer are not allowed to occur. Several features of Java combine to provide this safety, including the class model, the garbage-collected [[JVM#Heap|heap]], and the verifier.

The JVM ''verifies'' all bytecode before it is executed. This verification consists primarily of three types of checks:

* Branches are always to valid locations
* Data is always initialized and references are always type-safe
* Access to &quot;private&quot; or &quot;package private&quot; data and methods is rigidly controlled.

The first two of these checks take place primarily during the &quot;verification&quot; step that occurs when a class is loaded and made eligible for use. The third is primarily performed dynamically, when data items or methods of a class are first accessed by another class.

The verifier permits only some bytecode sequences in valid programs, e.g. a [[branch (computer science)|jump (branch) instruction]] can only target an instruction within the same [[Method (computer programming)|method]]. Furthermore, the verifier ensures that any given instruction operates on a fixed stack location,&lt;ref&gt;{{cite web | title=The Verification process | url=http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#9766 | work=The Java Virtual Machine Specification | publisher=Sun Microsystems | year=1999 | accessdate=2009-05-31}}&lt;/ref&gt; allowing the JIT compiler to transform stack accesses into fixed register accesses. Because of this, that the JVM is a stack architecture does not imply a speed penalty for emulation on [[register machine|register-based architectures]] when using a JIT compiler. In the face of the code-verified JVM architecture, it makes no difference to a JIT compiler whether it gets named imaginary registers or imaginary stack positions that must be allocated to the target architecture's registers. In fact, code verification makes the JVM different from a classic stack architecture whose efficient emulation with a JIT compiler is more complicated and typically carried out by a slower interpreter.

Code verification also ensures that arbitrary bit patterns cannot get used as an address. [[Memory protection]] is achieved without the need for a [[memory management unit]] (MMU). Thus, JVM is an efficient way of getting memory protection on simple architectures that lack an MMU. This is analogous to [[managed code]] in Microsoft's .NET [[Common Language Runtime]], and conceptually similar to [[capability architecture]]s such as the [[Plessey 250]], and IBM [[System/38]].

The original specification for the bytecode verifier used natural language that was &quot;incomplete or incorrect in some respects.&quot; A number of attempts have been made to specify the JVM as a formal system. By doing this, the security of current JVM implementations can more thoroughly be analyzed, and potential security exploits prevented. It will also be possible to optimize the JVM by skipping unnecessary safety checks, if the application being run is proved to be safe.&lt;ref&gt;Stephen N. Freund and John C. Mitchell. 1999. A formal framework for the Java bytecode language and verifier. In Proceedings of the 14th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '99), A. Michael Berman (Ed.). ACM, New York, NY, USA, 147-166. DOI=10.1145/320384.320397 http://doi.acm.org/10.1145/320384.320397&lt;/ref&gt;

== Bytecode instructions ==
{{Main|Java bytecode}}

The JVM has [[instruction (computer science)|instructions]] for the following groups of tasks:

* Load and store
* [[Arithmetic]]
* [[Type conversion]]
* [[dynamic memory allocation|Object creation and manipulation]]
* [[stack (data structure)|Operand stack management (push / pop)]]
* [[branch (computer science)|Control transfer (branching)]]
* [[subroutine|Method invocation and return]]
* [[exception handling|Throwing exceptions]]
* [[monitor (synchronization)|Monitor-based concurrency]]

The aim is binary compatibility. Each particular host [[operating system]] needs its own implementation of the JVM and runtime. These JVMs interpret the bytecode semantically the same way, but the actual implementation may be different. More complex than just emulating bytecode is compatibly and efficiently implementing the [[Java Class Library|Java core API]] that must be mapped to each host operating system.

== Heap ==
The ''Java virtual machine heap'' is the area of memory used by the JVM (and specifically [[HotSpot]]) for [[dynamic memory allocation]].&lt;ref name=&quot;hotspotfaq&quot;&gt;{{cite web
| url=http://java.sun.com/docs/hotspot/gc1.4.2/faq.html
| title=Frequently Asked Questions about Garbage Collection in the Hotspot Java Virtual Machine
| date=6 February 2003
| publisher=[[Sun Microsystems]]
| accessdate=7 February 2009}}&lt;/ref&gt; The [[heap (data structure)|heap]] is split up into &quot;generations&quot;:
* The ''young generation'' stores short-lived [[object (computer science)|objects]] that are created and immediately [[garbage collection (computer science)|garbage collected]].
* Objects that persist longer are moved to the ''old generation'' (also called the ''tenured generation'').
* The ''permanent generation'' (or ''permgen'') is used for [[class (file format)|class]] definitions and associated metadata.&lt;ref name=&quot;permgen&quot;&gt;{{cite web
| url=http://blogs.sun.com/jonthecollector/entry/presenting_the_permanent_generation
| title=Presenting the Permanent Generation
| date=28 November 2006
| last=Masamitsu|first=Jon
| accessdate=7 February 2009}}&lt;/ref&gt;&lt;ref&gt;{{cite web
| url=http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html
| title=A First Taste of InvokeDynamic
| date=11 September 2008
| last=Nutter|first=Charles
| accessdate=7 February 2009}}&lt;/ref&gt;

Originally there was no permanent generation, and objects and classes were stored together in the same area. But as class unloading occurs much more rarely than objects are collected, moving class structures to a specific area allows significant performance improvements.&lt;ref name=permgen/&gt;

== Secure execution of remote code ==
A virtual machine architecture allows very fine-grained control over the actions that code within the machine is permitted to take. This is designed to allow safe execution of untrusted code from remote sources, a model used by [[Java applet]]s. Applets run within a VM incorporated into a user's browser, executing code downloaded from a remote [[HTTP]] server. The remote code runs in a restricted &quot;[[sandbox (security)|sandbox]]&quot;, which is designed to protect the user from misbehaving or malicious code. Publishers can purchase a certificate with which to [[digital signature|digitally sign]] applets as &quot;safe&quot;, giving them permission to ask the user to break out of the sandbox and access the local file system, [[clipboard (software)|clipboard]] or network.

== C to bytecode compilers ==
{{primary sources|section|date=November 2011}}

From the point of view of a [[compiler]], the Java virtual machine is just another processor with an instruction set, [[Java bytecode]], for which code can be generated. The JVM was originally designed to execute programs written in the Java language. However, the JVM provides an execution environment in the form of a bytecode instruction set and a runtime system that is general enough that it can be used as the target for [[compiler]]s of other [[programming language|languages]].

Because of its close association with the Java language, the JVM performs the strict runtime checks mandated by the Java specification. That requires [[C (programming language)|C]] to bytecode compilers to provide their own &quot;lax machine abstraction&quot;, for instance producing compiled code that uses a Java array to represent main memory (so pointers can be compiled to integers), and linking the C library to a centralized Java class that emulates system calls. Most or all of the compilers listed below use a similar approach.

Several C to bytecode compilers exist:
* [http://nestedvm.ibex.org/ NestedVM] translates C to MIPS machine language first before converting to Java bytecode.
* [http://cibyl.googlecode.com Cibyl] works similarly to NestedVM but targets J2ME devices.
* [http://da.vidr.cc/projects/lljvm/ LLJVM] compiles C to [[LLVM]] IR, which is then translated to JVM bytecode.
* [http://www.novosoft-us.com/solutions/product_c2j.shtml C2J] is also GCC-based, but it produces intermediary Java source code before generating bytecode.&lt;ref&gt;http://tech.novosoft-us.com/product_c2j_faq.jsp&lt;/ref&gt; Supports the full ANSI C runtime.
* [http://objectmix.com/compilers/37664-ampc-version-1-6-2-released-c-java-class-files-compiler.html Axiomatic Multi-Platform C] supports full ANSI C 1989, SWT, and J2ME CDC 1.1 for mobile devices.
* [http://www.itee.uq.edu.au/~cristina/uqbt.html#gcc-jvm Java Backend for GCC], possibly the oldest project of its kind, was developed at The University of Queensland in 1999.
* [http://sourceforge.net/projects/javum/ Javum] is an attempt to port the full GNU environment to the JVM, and includes one of the above compilers packaged with additional utilities.

Compilers targeting Java bytecode have been written for other programming languages, including [[Ada (programming language)|Ada]] and [[COBOL]].

== Licensing ==
Starting with [[Java Platform, Standard Edition|J2SE]] 5.0, changes to the JVM specification have been developed under the [[Java Community Process]] as JSR 924.&lt;ref&gt;[http://www.jcp.org/en/jsr/detail?id=924 JSR 924], specifies changes to the JVM specification starting with J2SE 5.0&lt;/ref&gt; {{As of|2006}}, changes to specification to support changes proposed to the [[class (file format)|class file format]] (JSR 202&lt;ref&gt;[http://www.jcp.org/en/jsr/detail?id=202 JSR 202], specifies a number of changes to the class file format&lt;/ref&gt;) are being done as a maintenance release of JSR 924. The specification for the JVM is published in book form,&lt;ref&gt;''[http://java.sun.com/docs/books/vmspec/ The Java Virtual Machine Specification]'' (the [http://java.sun.com/docs/books/vmspec/html/VMSpecTOC.doc.html first] and [http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html second] editions are also available online)&lt;/ref&gt; known as &quot;blue book&quot;. The preface states:
{{quote|We intend that this specification should sufficiently document the Java Virtual Machine to make possible compatible clean-room implementations. Oracle provides tests that verify the proper operation of implementations of the Java Virtual Machine.}}

Oracle's JVM is called [[HotSpot]]. [[clean room design|Clean-room]] Java implementations include [[Kaffe]] and [[IBM J9]]. Oracle retains control over the Java trademark, which it uses to certify implementation suites as fully compatible with Oracle's specification.

== See also ==
{{Portal|Java}}

* [[List of Java virtual machines]]
* [[Comparison of application virtual machines]]
* [[Automated Exception Handling]]
* [[Java performance]]
* [[List of JVM languages]]
* [[Java processor]]

== Notes ==
{{Reflist}}
{{Reflist|2}}

==References==
{{Refbegin}}
* ''[http://java.sun.com/docs/books/vmspec/2nd-edition/jvms-clarify.html Clarifications and Amendments to the Java Virtual Machine Specification, Second Edition]'' includes list of changes to be made to support J2SE 5.0 and JSR 45
* [http://www.jcp.org/en/jsr/detail?id=45 JSR 45], specifies changes to the class file format to support source-level debugging of languages such as [[JavaServer Pages]] (JSP) and [[SQLJ]] that are translated to Java
{{Refend}}

==External links==
* [http://java.sun.com/docs/books/vmspec/ The Java Virtual Machine Specification]
* {{dmoz|Computers/Programming/Languages/Java/Implementations|Java implementations}}
* [http://www.computerworld.com/action/article.do?command=viewArticleBasic&amp;articleId=9067358 Sun to build virtual machine for iPhone - ComputerWorld]
* [http://java.com/en/download/inc/windows_new_xpi.jsp Java Virtual Machine Download Link]
* [http://igormaznitsa.com/projects/mjvm/index.html JVM implementation in pure Java]

{{Java Virtual Machine}}
{{Java (Sun)}}
{{Sun Microsystems}}

&lt;!-- Categories --&gt;
[[Category:Cross-platform software]]
[[Category:Java platform|Virtual machine]]
[[Category:Java platform software]]
[[Category:Java programming language|Virtual machine]]
[[Category:Java specification requests|Virtual machine]]
[[Category:Java virtual machine]]
[[Category:Stack-based virtual machines]]

&lt;!-- Interwikis --&gt;

[[ar:Ø¢ÙØ© Ø¬Ø§ÙØ§ Ø§ÙØ§ÙØªØ±Ø§Ø¶ÙØ©]]
[[bs:Java Virtualna MaÅ¡ina]]
[[ca:MÃ quina Virtual Java]]
[[cs:Java Virtual Machine]]
[[de:Java Virtual Machine]]
[[es:MÃ¡quina virtual Java]]
[[fa:ÙØ§Ø´ÛÙ ÙØ¬Ø§Ø²Û Ø¬Ø§ÙØ§]]
[[fr:Machine virtuelle Java]]
[[ko:ìë° ê°ì ë¨¸ì ]]
[[hi:à¤à¤¾à¤µà¤¾ à¤à¤­à¤¾à¤¸à¥ à¤®à¤¶à¥à¤¨]]
[[hr:Java (virtualni stroj)]]
[[id:Mesin virtual java]]
[[it:Macchina virtuale Java]]
[[he:Java Virtual Machine]]
[[hu:Java virtuÃ¡lis gÃ©p]]
[[ml:à´à´¾à´µ à´µà´¿àµ¼à´àµà´àµà´µàµ½ à´®àµà´·àµàµ»]]
[[my:Java áá¼ááºáá²á·áááº(JVM)]]
[[nl:Java Virtual Machine]]
[[ja:Javaä»®æ³ãã·ã³]]
[[pl:Wirtualna maszyna Javy]]
[[pt:MÃ¡quina virtual Java]]
[[ru:Java Virtual Machine]]
[[sq:Java Virtual Machine]]
[[simple:Java Virtual Machine]]
[[sh:Java (virtualni stroj)]]
[[sv:Java Virtual Machine]]
[[tr:Java Sanal Makinesi]]
[[uk:ÐÑÑÑÑÐ°Ð»ÑÐ½Ð° Ð¼Ð°ÑÐ¸Ð½Ð° Java]]
[[zh:Javaèææº]]</rev></revisions></page></pages></query></api>
