<?xml version="1.0"?><api><query><pages><page pageid="12323" ns="0" title="GNU Compiler Collection"><revisions><rev xml:space="preserve">{{Redirect|Cc1|other uses of CC1 or CC-1|CC1 (disambiguation)}}
{{Infobox software
| name                   = GNU Compiler Collection
| logo                   = [[File:Gccegg.svg|100px]]
| developer              = [[GNU Project]]
| released               = {{start date|1987|05|23}}&lt;ref name=&quot;release-history&quot;&gt;{{cite web
 | url = http://www.gnu.org/software/gcc/releases.html
 | title = GCC Releases
 | accessdate = 2006-12-27
 | publisher = GNU Project
}}&lt;/ref&gt;
| latest release version = 4.6.2 &lt;!-- sync this with [[GNU Compiler for Java]] --&gt;
| latest release date    = {{release date|2011|10|26}} &lt;!-- sync this with [[GNU Compiler for Java]] --&gt;
| programming language   = [[C (programming language)|C]], [[C++]]
| operating system       = [[Cross-platform]]
| platform               = [[GNU]]
| genre                  = [[Compiler]]
| license                = [[GNU General Public License]] (version 3 or later)
| website                = http://gcc.gnu.org
}}

The '''GNU Compiler Collection''' ('''GCC''') is a [[compiler]] system produced by the [[GNU Project]] supporting various [[programming language]]s. GCC is a key component of the [[GNU toolchain]]. As well as being the official compiler of the unfinished [[GNU]] operating system, GCC has been adopted as the standard compiler by most other modern [[Unix-like]] computer [[operating system]]s, including [[Linux]], the [[Berkeley Software Distribution|BSD]] family and [[Mac OS X]]. A port to [[RISC OS]] has also been developed extensively in recent years.&lt;ref&gt;{{cite web
| accessdate = 2011-06-16
| location = http://www.wordiq.com/
| publisher = wordiQ
| title = GNU Compiler Collection - Definition
| quote = It is the standard compiler for the open source Unix-like operating systems, and certain proprietary operating systems derived therefrom such as Mac OS X.
| url = http://www.wordiq.com/definition/GNU_Compiler_Collection}}&lt;/ref&gt; There is also an old (3.0) port of GCC to [[Plan 9 from Bell Labs|Plan9]], running under its [[ANSI/POSIX Environment]] (APE). &lt;ref&gt;{{cite web
| accessdate = 2011-09-06
| url = http://plan9.bell-labs.com/wiki/plan9/porting_alien_software_to_plan_9/index.html
| publisher = Bell Labs, Lucent
| title = Porting alien software to Plan 9 &amp;#124; }} &lt;/ref&gt; GCC is also available for the widely-used [[Microsoft Windows]] operating systems, and for the [[ARM]] processor used by many portable devices.

GCC has been [[porting|ported]] to a wide variety of [[processor architecture]]s, and is widely deployed as a tool in commercial, [[proprietary software|proprietary]] and [[closed source software]] development environments. GCC is also available for most embedded platforms, for example [[Symbian]] (called ''gcce''),&lt;ref&gt;{{cite web|url=http://www.inf.u-szeged.hu/symbian-gcc/|title=Symbian GCC Improvement Project|accessdate=2007-11-08}}&lt;/ref&gt; [[Applied_Micro_Circuits_Corporation|AMCC]] and [[Freescale]] [[Power Architecture]]-based chips.&lt;ref&gt;{{cite web|url=http://www.freescale.com/webapp/sps/site/overview.jsp?code=CW_BSP&amp;fsrch=1|title=Linux Board Support Packages|accessdate=2008-08-07}}&lt;/ref&gt; The compiler can target a wide variety of platforms, including [[videogame consoles]] such as the [[PlayStation 2]]&lt;ref&gt;{{cite web |url=http://ps2stuff.playstation2-linux.com/gcc_build.html |title=setting up gcc as a cross-compiler |work=ps2stuff |date=2002-06-08 |accessdate=2008-12-12}} {{Dead link|date=September 2010|bot=H3llBot}}&lt;/ref&gt; and [[Dreamcast]].&lt;ref&gt;{{cite web |url=http://www.ngine.de/gccguide.html |title=sh4 g++ guide |archiveurl=http://web.archive.org/web/20021220025554/http://www.ngine.de/gccguide.html |archivedate=2002-12-20 |accessdate=2008-12-12 |quote=This guide is intended for people who want to compile C++ code for their Dreamcast systems }}&lt;/ref&gt; Several companies&lt;ref&gt;{{cite web|url=http://www.fsf.org/resources/service|title=FSF Service Directory}}&lt;/ref&gt; make a business out of supplying and supporting GCC ports to various platforms, and chip manufacturers today consider a GCC port almost essential to the success of an architecture.{{Citation needed|date=November 2011}}

Originally named the '''GNU C Compiler''', because it only handled the [[C (programming language)|C programming language]], GCC 1.0 was released in 1987, and the compiler was extended to compile [[C++]] in December of that year.&lt;ref name=&quot;release-history&quot;/&gt; [[Compiler#Front_end|Front ends]] were later developed for [[Objective-C]], [[Objective-C#Objective-C++|Objective-C++]], [[Fortran]], [[Java (programming language)|Java]], [[Ada (programming language)|Ada]], and [[Go (programming language)|Go]] among others.&lt;ref&gt;{{cite web|url=http://gcc.gnu.org/onlinedocs/gcc-4.6.0/gcc/G_002b_002b-and-GCC.html|title=Programming Languages Supported by GCC|accessdate=2011-11-25|publisher=GNU Project}}&lt;/ref&gt;

The [[Free Software Foundation]] (FSF) distributes GCC under the [[GNU General Public License]] (GNU GPL). GCC has played an important role in the growth of [[free software]], as both a tool and an example.

==History==

[[Richard Stallman]]'s initial plan&lt;ref name=LLLCompiler&gt;
{{Cite web
  | last = Stallman
  | first = Richard
  | title = About the GNU Project
  | publisher = The GNU Project
  | date = September 20, 2011
  | url = http://www.gnu.org/gnu/thegnuproject.html
  | quote = Hoping to avoid the need to write the whole compiler myself, I obtained the source code for the Pastel compiler, which was a multiplatform compiler developed at Lawrence Livermore Lab. It supported, and was written in, an extended version of Pascal, designed to be a system-programming language. I added a C front end, and began porting it to the Motorola 68000 computer. But I had to give that up when I discovered that the compiler needed many megabytes of stack space, and the available 68000 Unix system would only allow 64k. ... I concluded I would have to write a new compiler from scratch. That new compiler is now known as GCC; none of the Pastel compiler is used in it, but I managed to adapt and use the C front end that I had written.
  | accessdate = October 9, 2011}}
&lt;/ref&gt; was to rewrite an existing compiler from Lawrence Livermore Lab from Pastel to C with some help from Len Tower and others.&lt;ref&gt;
{{cite journal
 | editor-last = Puzo
 | editor-first = Jerome E.
 | title = Gnu's Zoo
 | journal = GNU'S Bulletin
 | volume = 1
 | issue = 1
 | date = February 1986
 | publisher = Free Software Foundation
 | url = http://www.gnu.org/bulletins/bull1.txt
 | quote = Although I have a portable C and Pascal compiler, ... most of the compiler is written in Pastel, ... so it must all be rewritten into C.  Len Tower, the sole full-time GNU staff person, is working on this, with one or two assistants. 
 | accessdate = 2007-08-11}}
&lt;/ref&gt;  Stallman wrote a new C front end for the Livermore compiler but then realized that it required megabytes of stack space, an impossibility on a 68000 Unix system with only 64K, and concluded he would have to write a new compiler from scratch.&lt;ref name=LLLCompiler/&gt;  None of the Pastel compiler code ended up in GCC, though Stallman did use the C front end he had written.&lt;ref name=LLLCompiler/&gt;

GCC was first released March 22, 1987, available by [[File transfer protocol|ftp]] from [[Massachusetts Institute of Technology|MIT]].&lt;ref&gt;
{{Cite newsgroup 
  | title = GNU C compiler beta test release
  | author = Richard M. Stallman (forwarded by Leonard H. Tower Jr.)
  | date = March 22, 1987
  | newsgroup = comp.lang.c
  | id = 
  | url = http://groups.google.com/group/comp.lang.misc/msg/32eda22392c20f98
  | accessdate = October 9, 2011
  | quote =  The GNU C compiler is now available for ftp from the file /u2/emacs/gcc.tar on prep.ai.mit.edu.  This includes machine descriptions for vax and sun, 60 pages of documentation on writing machine descriptions ... the ANSI standard (Nov 86) C preprocessor and 30 pages of reference manual for it.  This compiler compiles itself correctly on the 68020 and did so recently on the vax.  It recently compiled Emacs correctly on the 68020, and has also compiled tex-in-C and Kyoto Common Lisp.
}}
&lt;/ref&gt;  Stallman was listed as the author but cited others for their contributions, including Jack Davidson and Christopher Fraser for the idea of using [[Register transfer language|RTL]] as an intermediate language, Paul Rubin for writing most of the preprocessor and Leonard Tower for &quot;parts of the parser, RTL generator, RTL definitions, and of the Vax machine description.&quot;&lt;ref name=GccContributors&gt;
{{Citation
  | last = Stallman
  | first = Richard M.
  | title = Internals of GNU CC
  | url = http://trinity.engr.uconn.edu/~vamsik/internals.pdf
  | publisher = Free Software Foundation, Inc.
  | date = 24 April 1988
  | chapter = Contributors to GNU CC
  | page = 7
  | quote = The idea of using RTL and some of the optimization ideas came from the U. of Arizona Portable Optimizer, written by Jack Davidson and Christopher Fraser. ... Leonard Tower wrote parts of the parser, RTL generator, RTL definitions, and of the Vax machine description.
  | accessdate = October 3, 2011
 }}
&lt;/ref&gt;

By 1991, GCC 1.x had reached a point of stability, but architectural limitations prevented many desired improvements, so the FSF started work on GCC 2.x.{{Citation needed|date=August 2011}}

As GCC was licensed under the GPL, programmers wanting to work in other directionsâparticularly those writing interfaces for languages other than [[C (programming language)|C]]âwere free to develop their own [[fork (software)|fork]] of the compiler{{Citation needed|date=August 2011}} (provided they meet the GPL's terms, including its requirements to distribute [[source code]]). Multiple forks proved inefficient and unwieldy,{{Citation needed|date=August 2011}} however, and the difficulty in getting work accepted by the official GCC project was greatly frustrating for many.{{Citation needed|date=August 2011}} The FSF kept such close control on what was added to the official version of GCC 2.x{{Citation needed|date=August 2011}} that GCC was used as one example of the &quot;cathedral&quot; development model in [[Eric S. Raymond]]'s essay ''[[The Cathedral and the Bazaar]]''.

With the release of [[4.4BSD]] in 1994, GCC became the default compiler for most BSD systems.{{Citation needed|date=August 2011}}

===EGCS fork===
In 1997, a group of developers formed EGCS (Experimental/Enhanced GNU Compiler System),&lt;ref&gt;{{cite web|title=Pentium Compiler FAQ|url=http://home.schmorp.de/pgcc-faq.html#egcs}}&lt;/ref&gt; to merge several experimental forks into a single project. The basis of the merger was a GCC development snapshot taken between the 2.7 and 2.81 releases. Projects merged included g77 ([[Fortran|FORTRAN]]), PGCC ([[P5 (microarchitecture)|P5]] [[Pentium (brand)|Pentium]]-optimized GCC), many [[C++]] improvements, and many new architectures and [[operating system]] variants.&lt;ref&gt;{{cite web|title=A Brief History of GCC|url=http://gcc.gnu.org/wiki/History}}&lt;/ref&gt;&lt;ref&gt;{{cite web|title=The Short History of GCC development|url=http://www.softpanorama.org/People/Stallman/history_of_gcc_development.shtml}}&lt;/ref&gt;

EGCS development proved considerably more vigorous than GCC development, so much so that the FSF officially halted development on their GCC 2.x compiler, &quot;blessed&quot; EGCS as the official version of GCC and appointed the EGCS project as the GCC maintainers in April 1999. Furthermore, the project explicitly adopted the &quot;bazaar&quot; model over the &quot;cathedral&quot; model. With the release of GCC 2.95 in July 1999, the two projects were once again united.

GCC is now maintained by a varied group of programmers from around the world, under the direction of a steering committee.&lt;ref&gt;{{cite web
 |url=http://gcc.gnu.org/steering.html
 |title=GCC steering committee}}&lt;/ref&gt;
It has been ported to more kinds of [[central processing unit|processors]] and [[operating system]]s than any other compiler.&lt;ref&gt;[http://www.linfo.org/gcc.html Linux Information Project] (LINFO) accessed 2010-04-27&lt;/ref&gt;

== Development ==

=== GCC stable release ===
The current stable version of GCC is '''4.6.2''', which was released on October 26, 2011.

GCC 4.6 supports many new [[Objective-C]] features, such as declared and synthesized properties, dot syntax, fast enumeration, optional protocol methods, method/protocol/class attributes, class extensions and a new GNU Objective-C runtime API. It also supports the [[Go programming language]] and includes the &lt;code&gt;libquadmath&lt;/code&gt; library, which provides [[Quadruple_precision_floating-point_format|quadruple-precision]] mathematical functions on targets supporting the &lt;code&gt;__float128&lt;/code&gt; datatype. The library is used to provide the &lt;code&gt;REAL(16)&lt;/code&gt; type in GNU [[Fortran]] on such targets.

GCC uses many standard tools in its build, including [[Perl]], [[Flex_lexical_analyser|Flex]], [[GNU_bison|Bison]], and other common tools.  In addition it currently requires three additional libraries to be present in order to build: [[GNU_Multi-Precision_Library|GMP]], [[Multiple Precision Complex|MPC]], and [[MPFR]].

The previous major version, '''4.5''', was initially released on April 14, 2010 (last minor version is 4.5.3, released on April 29, 2011). It included several minor new features (new targets, new language dialects) and a couple major new features:
* ''Link-time optimization'' optimizes across object file boundaries to directly improve the linked binary. Link-time optimization relies on an intermediate file containing the serialization of some -Gimple- representation included in the object file [http://gcc.gnu.org/wiki/LinkTimeOptimization]. The file is generated alongside the object file during source compilation. Each source compilation generates a separate object file and link-time helper file. When the object files are linked, the compiler is executed again and uses the helper files to optimize code across the separately compiled object files.
* ''[[Plugins]]'' can extend the GCC compiler directly [http://gcc.gnu.org/onlinedocs/gccint/Plugins.html]. Plugins allow a stock compiler to be tailored to specific needs by external code loaded as plugins. For example, plugins can add, replace, or even remove middleâend passes operating on ''Gimple'' representations. Several GCC plugins have already been published, notably:
** [https://developer.mozilla.org/en/Treehydra TreeHydra] to help with Mozilla code development
** [http://dragonegg.llvm.org/ DragonEgg] to use the GCC front-end with [[LLVM]]
** [http://gcc.gnu.org/wiki/MiddleEndLispTranslator MELT] (site [http://gcc-melt.org/ GCC MELT]) to enable coding GCC extensions in a [[Lisp (programming language)|lisp]]y [[Domain Specific Language|domain-specific language]] providing powerful [[Pattern-matching]]
** [http://ctuning.org/wiki/index.php/CTools:MilepostGCC MILEPOST] [http://ctuning.org/ CTuning] to use [[machine learning]] techniques to tune the compiler.

=== GCC trunk ===
The trunk concentrates the major part of the development efforts, where new features are implemented and tested. Eventually, the code from the trunk will become the next major release of GCC, with version '''4.7'''. &lt;!-- planned features to be added here --&gt;

==Uses==
GCC is often chosen for developing software that is required to execute on a wide variety of hardware and/or operating systems.{{Citation needed|date=March 2011}} System-specific compilers provided by hardware or OS vendors can differ substantially, complicating both the software's source code and the scripts that invoke the compiler to build it.{{Citation needed|date=March 2011}} With GCC, most of the compiler is the same on every platform, so only code that explicitly uses platform-specific features must be rewritten for each system.{{Citation needed|date=March 2011}}

==Languages==
&lt;!-- dates of the first release for each language would be a useful add. --&gt;
The standard compiler release 4.6 includes front ends for [[C (programming language)|C]] (&lt;tt&gt;gcc&lt;/tt&gt;), [[C++]] (&lt;tt&gt;g++&lt;/tt&gt;), [[Objective-C]] (&lt;tt&gt;gobjc&lt;/tt&gt;), [[Fortran]] (&lt;tt&gt;[[gfortran]]&lt;/tt&gt;), [[Java (programming language)|Java]] (&lt;tt&gt;[[gcj]]&lt;/tt&gt;), [[Ada (programming language)|Ada]] ([[GNAT]]), and [[Go (programming language)|Go]] (&lt;tt&gt;gccgo&lt;/tt&gt;).&lt;ref&gt;[http://gcc.gnu.org/frontends.html &quot;GCC Front Ends&quot;], gnu.org, Retrieved November 25, 2011.&lt;/ref&gt; Also available, but not in standard are [[Pascal (programming language)|Pascal]] (&lt;tt&gt;[[GNU Pascal|gpc]]&lt;/tt&gt;), [[Mercury (programming language)|Mercury]], [[Modula-2]], [[Modula-3]], [[PL/I]], [[D (programming language)|D]] (&lt;tt&gt;gdc&lt;/tt&gt;){{Citation needed|date=November 2011}}, and [[VHDL]] (&lt;tt&gt;ghdl&lt;/tt&gt;). A popular parallel language extension, [[OpenMP]], is also supported.

The Fortran front end was &lt;tt&gt;g77&lt;/tt&gt; before version 4.0, which only supports [[FORTRAN 77]]. In newer versions, &lt;tt&gt;g77&lt;/tt&gt; is dropped in favor of the new &lt;tt&gt;[[gfortran]]&lt;/tt&gt; front end that supports [[Fortran 95]] and parts of [[Fortran 2003]] as well.&lt;ref&gt;{{cite web|url=http://gcc.gnu.org/wiki/Fortran2003|title=Fortran 2003 Features in GNU Fortran}}&lt;/ref&gt; As the later Fortran standards incorporate the F77 standard, standards-compliant F77 code is also standards-compliant F90/95 code, and so can be compiled without trouble in gfortran. A front-end for [[CHILL]] was dropped due to a lack of maintenance.&lt;ref&gt;[http://gcc.gnu.org/ml/gcc-patches/2002-04/msg00887.html [PATCH&amp;#93; Remove chill], gcc.gnu.org, Retrieved July 29, 2010.&lt;/ref&gt;

A few experimental branches exist to support additional languages, such as the GCC [[Unified Parallel C|UPC]] compiler&lt;ref&gt;{{cite web|url=http://www.intrepid.com/upc.html |title=GCC UPC (GCC Unified Parallel C) &amp;#124; intrepid.com |publisher=intrepid.com&lt;! |date=2006-02-20 |accessdate=2009-03-11}}&lt;/ref&gt; for [[Unified Parallel C]].

==Architectures==
GCC target processor families as of version 4.3 include:

{{div col|colwidth=15em|small=no}}
* [[DEC Alpha|Alpha]]
* [[ARM architecture|ARM]]
* [[Atmel AVR]]
* [[Blackfin]]
* [[Hitachi H8|H8/300]]
* [[HC12]]
* [[IA-32]] ([[X86 architecture|x86]])
* [[IA-64]]
* [[MIPS architecture|MIPS]]
* [[Motorola 68000]]
* [[PA-RISC]]
* [[PDP-11]]
* [[PowerPC]]
* [[R8C]]/[[M16C]]/[[M32C]]
* [[SPARC]]
* [[Synergistic Processing Unit|SPU]]
* [[SuperH]]
* [[System/390]]/[[zSeries]]
* [[VAX]]
* [[x86-64]]
{{Refend}}

Lesser-known target processors supported in the standard release have included:

{{div col|colwidth=15em|small=no}}
* [[Freescale 68HC11|68HC11]]
* [[AMD Am29000|A29K]]
* [[ARC International|ARC]]
* [[AVR32]]
* [[D30V]]
* [[DSP16xx]]
* [[ETRAX CRIS]]
* [[FR-30]]
* [[FR-V]]
* [[Intel i960]]
* [[IP2000]]
* [[M32R]]
* [[MCORE]]
* [[MIL-STD-1750A]]
* [[MMIX]]
* [[MN10200]]
* [[MN10300]]
* [[Motorola 88000]]
* [[NS320xx|NS32K]]
* [[ROMP]]
* [[Stormy16]]
* [[V850]]
* [[Xtensa]]
{{Refend}}

Additional processors have been supported by GCC versions maintained separately from the FSF version:

{{div col|colwidth=15em|small=no}}
* [[Cortus APS3]]
* [[D10V]]
* [[EISC]]
* [[eSi-RISC]]
* [[Hexagon (processor)|Hexagon]]&lt;ref&gt;{{cite web|title=Hexagon Project Wiki|url=https://www.codeaurora.org/xwiki/bin/Hexagon/}}
{{cite web|title=Hexagon dowload|url=https://www.codeaurora.org/patches/quic/hexagon/&quot;}}&lt;/ref&gt;
* [[LatticeMico32]]
* [[LatticeMico8]]
* [[MeP]]
* [[MicroBlaze]]
* [[6809|Motorola 6809]]
* [[TI MSP430|MSP430]]
* [[NEC SX architecture]]&lt;ref&gt;{{cite web|title=sx-gcc: port gcc to nec sx vector cpu|url=http://code.google.com/p/sx-gcc/}}&lt;/ref&gt;
* [[Nios II]] and [[Nios embedded processor|Nios]]
* [[OpenRISC 1200]]
* [[PDP-10]]
* [[PIC30#PIC24 and dsPIC 16-bit microcontrollers|PIC24/dsPIC]]
* [[System/370]]
* [[TIGCC]] ([[Motorola 68000|m68k]] variant)
* [[Zilog Z8000|Z8000]]
{{Refend}}

The [[gcj]] Java compiler can target either a native machine language architecture or the [[Java Virtual Machine]]'s [[Java bytecode]].&lt;ref&gt;{{cite web | url = http://gcc.gnu.org/java/ | title = The GNU Compiler for the Java Programming Language | accessdate = 2010-04-22}}&lt;/ref&gt; When [[retargetable compiler|retargeting]] GCC to a new platform, [[bootstrapping (compilers)|bootstrapping]] is often used.

==Structure==
GCC's external interface is generally standard for a [[UNIX]] compiler. Users invoke a driver program named &lt;code&gt;gcc&lt;/code&gt;, which interprets [[Command-line argument|command arguments]], decides which language compilers to use for each input file, runs the [[Assembly language#Assembler|assembler]] on their output, and then possibly runs the [[Linker (computing)|linker]] to produce a complete [[executable]] binary.

Each of the language compilers is a separate program that inputs source code and outputs [[machine code]]. All have a common internal structure. A per-language front end [[parsing|parses]] the source code in that language and produces an [[abstract syntax tree]] (&quot;tree&quot; for short).

These are, if necessary, converted to the middle-end's input representation, called ''GENERIC'' form; the middle-end then gradually transforms the program towards its final form. [[Compiler optimization]]s and [[static code analysis]] techniques (such as FORTIFY_SOURCE,&lt;ref&gt;{{cite web|url=http://fedoraproject.org/wiki/Security/Features |title=Security Features: Compile Time Buffer Checks (FORTIFY_SOURCE) |publisher=fedoraproject.org |accessdate=2009-03-11}}&lt;/ref&gt; a compiler directive that attempts to discover some [[buffer overflow]]s) are applied to the code. These work on multiple representations, mostly the architecture-independent GIMPLE representation and the architecture-dependent [[Register Transfer Language|RTL]] representation. Finally, [[machine code]] is produced using architecture-specific [[pattern matching]] originally based on an algorithm of [[Jack Davidson]] and Chris Fraser.

GCC is written primarily in [[C (programming language)|C]] except for parts of the [[Ada (programming language)|Ada]] front end. The distribution includes the standard libraries for Ada, [[C++]], and [[Java (programming language)|Java]] whose code is mostly written in those languages.&lt;ref&gt;{{cite web | url = http://www.ohloh.net/projects/gcc/analyses/latest | title = languages used to make GCC }}&lt;/ref&gt;&lt;!-- primary source --&gt; On some platforms, the distribution also includes a low-level runtime library, '''libgcc''', written in a combination of machine-independent C and processor-specific [[machine code]], designed primarily to handle arithmetic operations that the target processor cannot perform directly.&lt;ref&gt;[http://gcc.gnu.org/onlinedocs/gccint/Libgcc.html GCC Internals], GCC.org, Retrieved March 01, 2010.&lt;/ref&gt;

In May 2010, the GCC steering committee decided to allow use of a [[C++]] compiler to compile GCC.&lt;ref&gt;
{{cite news
 |title=GCC allows C++ â to some degree
 |url=http://www.h-online.com/open/news/item/GCC-allows-C-to-some-degree-1012611.html
 |publisher=[[Heinz Heise|The H]] |date=1 June 2010}}&lt;/ref&gt;  The compiler will be written in C plus a subset of features from C++.  In particular, this was decided so that GCC's developers could use the &quot;[[Destructor (computer science)|destructors]]&quot; and &quot;[[Generic programming|generics]]&quot; features of C++.&lt;ref&gt;{{cite web|url=http://lists.gnu.org/archive/html/emacs-devel/2010-07/msg00518.html|title=An email by Richard Stallman on emacs-devel|quote=The reason the GCC developers wanted to use it is for destructors and generics.  These aren't much use in Emacs, which has GC and in which data types are handled at the Lisp level.}}&lt;/ref&gt;

===Front-ends===
Frontends vary internally, having to produce trees that can be handled by the backend. Currently, the parsers are all hand-coded [[recursive descent parser]]s, though there is no reason why a [[parser generator]] could not be used for new front-ends in the future (version 2 of the C compiler used a [[GNU bison|bison]] based grammar).

Until recently, the tree representation of the program was not fully independent of the processor being targeted.

The meaning of a tree was somewhat different for different language front-ends, and front-ends could provide their own tree codes. This was simplified with the introduction of GENERIC and GIMPLE, two new forms of language-independent trees that were introduced with the advent of GCC 4.0. GENERIC is more complex, based on the GCC 3.x Java front-end's intermediate representation. GIMPLE is a simplified GENERIC, in which various constructs are ''lowered'' to multiple GIMPLE instructions. The [[C (Programming Language)|C]], [[C++]] and [[Java (programming language)|Java]] front ends produce GENERIC directly in the front end. Other front ends instead have different intermediate representations after parsing and convert these to GENERIC.

In either case, the so-called &quot;gimplifier&quot; then lowers this more complex form into the simpler [[Static single assignment form|SSA]]-based GIMPLE form that is the common language for a large number of new powerful language- and architecture-independent global (function scope) optimizations.

===GENERIC and GIMPLE===
''GENERIC'' is an [[intermediate representation]] language used as a &quot;middle-end&quot; while compiling source code into executable binaries. A subset, called ''GIMPLE'', is targeted by all the front-ends of GCC.

The middle stage of GCC does all the code analysis and optimization, working independently of both the compiled language and the target architecture, starting from the GENERIC&lt;ref&gt;[http://gcc.gnu.org/onlinedocs/gccint/GENERIC.html GENERIC] in GNU Compiler Collection Internals&lt;/ref&gt; representation and expanding it to [[Register Transfer Language]]. The GENERIC representation contains only the subset of the imperative [[computer programming|programming]] constructs optimised by the middle-end.

In transforming the source code to GIMPLE&lt;ref&gt;[http://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html GIMPLE] in GNU Compiler Collection Internals&lt;/ref&gt;, complex [[Expression (programming)|expressions]] are split into a [[three address code]] using [[temporary variable]]s. This representation was inspired by the SIMPLE representation proposed in the McCAT [[compiler]]&lt;ref&gt;[http://web.archive.org/web/20040812030043/www-acaps.cs.mcgill.ca/info/McCAT/McCAT.html McCAT]&lt;/ref&gt; by Laurie J. Hendren&lt;ref&gt;[http://www.sable.mcgill.ca/~hendren/ Laurie J. Hendren]&lt;/ref&gt; for simplifying the analysis and [[Optimization (computer science)|optimization]] of [[Imperative programming|imperative programs]].

===Optimization===
Optimization can occur during any phase of compilation, however the bulk of optimizations are performed after the syntax and semantic analysis of the front-end and before the code generation of the back-end, thus a common, even though somewhat contradictory, name for this part of the compiler is &quot;middle end.&quot;

The exact set of GCC optimizations varies from release to release as it develops, but includes the standard algorithms, such as [[loop optimization]], [[jump threading]], [[common subexpression elimination]], [[instruction scheduling]], and so forth. The [[Register transfer language|RTL]] optimizations are of less importance with the addition of global SSA-based optimizations on [[GIMPLE]] trees,&lt;ref&gt;
[http://www.redhat.com/magazine/002dec04/features/gcc/ From Source to Binary: The Inner Workings of GCC], by Diego Novillo, [[Red Hat#Red Hat Magazine|''Red Hat Magazine'']], December 2004&lt;/ref&gt;
as RTL optimizations have a much more limited scope, and have less high-level information.

Some of these optimizations performed at this level include [[dead code elimination]], [[partial redundancy elimination]], [[global value numbering]], [[sparse conditional constant propagation]], and [[scalar replacement of aggregates]]. Array dependence based optimizations such as [[automatic vectorization]] and [[automatic parallelization]] are also performed. [[Profile-guided optimization]] is also possible as demonstrated here: http://gcc.gnu.org/install/build.html#TOC4

===Back-end===
The behavior of GCC's back end is partly specified by [[C preprocessor|preprocessor macros]] and functions specific to a target architecture, for instance to define the [[endianness]], [[word size]], and [[calling convention]]s. The front part of the back end uses these to help decide RTL generation, so although GCC's RTL is nominally processor-independent, the initial sequence of abstract instructions is already adapted to the target. At any moment, the actual RTL instructions forming the program representation have to comply with the [[machine description]] of the target architecture.

The machine description file contains RTL patterns, along with operand constraints, and code snippets to output the final assembly.  The constraints indicate that a particular RTL pattern might only apply (for example) to certain hardware registers, or (for example) allow immediate operand offsets of only a limited size (''e.g.'' 12, 16, 22, ... bit offsets, etc.). During RTL generation, the constraints for the given target architecture are checked. In order to issue a given snippet of RTL, it must match one (or more) of the RTL patterns in the machine description file, and satisfy the constraints for that pattern; otherwise, it would be impossible to convert the final RTL into machine code.

Towards the end of compilation, valid RTL is reduced to a ''strict'' form in which each instruction refers to real machine registers and a pattern from the target's machine description file. Forming strict RTL is a complicated task; an important step is [[register allocation]], where real, hardware registers are chosen to replace the initially-assigned pseudo-registers. This is followed by a &quot;reloading&quot; phase; any pseudo-registers that were not assigned a real hardware register are 'spilled' to the stack, and RTL to perform this spilling is generated. Likewise, offsets that are too large to fit in an actual instruction must be broken up and replaced by RTL sequences that will obey the offset constraints.

In the final phase the machine code is built by calling a small snippet of code, associated with each pattern, to generate the real instructions from the target's [[instruction set]], using the final registers, offsets and addresses chosen during the reload phase. The assembly-generation snippet may be just a string; in which case, a simple string substitution of the registers, offsets, and/or addresses into the string is performed.  The assembly-generation snippet may also be a short block of C code, performing some additional work, but ultimately returning a string containing the valid machine code.

==Compatible IDEs==
Most [[integrated development environment]]s written for [[GNU/Linux]] and some for other operating systems support GCC. These include:
{{Refbegin|3}}
* [[Anjuta]]
* [[Code::Blocks]]
* [[CodeLite]]
* [[Dev-C++]]
* [[Eclipse (software)|Eclipse]]
* [[geany]]
* [[KDevelop]]
* [[NetBeans]]
* [[Qt Creator]]
* [[Xcode]]
{{Refend}}

==Debugging GCC programs==
The primary tool used to debug GCC code is the [[GNU Debugger]] (gdb). Among more specialized tools are [[Valgrind]], for finding memory errors and leaks, and the graph profiler ([[gprof]]) that can determine how much time is spent in which routines, and how often they are called; this requires programs to be compiled with [[Software profiling|profiling]] options.

== Criticism ==
GCC is frequently criticised for its performance, code quality and development practices:
{{quotation|I would love a new C compiler, but mostly because I feel that the gcc model is unmaintainable in the long term. What the gcc people have created is a compiler that is heavy on optimization. The result of their imperfect efforts thus is a compiler that generates incorrect code from time to time, and this affects us all. That also makes it very slow. I would love to see a new C compiler that was fully compliant, did minimal optimization, was small and fast, and high quality.|[[Theo de Raadt]]&lt;ref&gt;{{citation
|url        = http://kerneltrap.org/node/6550
|title      = Interview: Theo de Raadt
|first      = Jeremy
|last       = Andrews
|authorlink = Jeremy Andrews
|work       = [[KernelTrap]]
|date       = 2006-05-02
|accessdate = 2011-12-03
}}&lt;/ref&gt;}}
{{quotation|Are you surprised? The gcc developers seem to have had a total disregard for what people want or need, and every time some code generation issue comes up, there's a lot of people on the list that do language-lawyering, rather than admit that there might be a problem.|[[Linus Torvalds]]&lt;ref&gt;{{cite mailing list
|url         = http://kerneltrap.org/mailarchive/linux-kernel/2007/10/25/355205
|title       = Re: Is gcc thread-unsafe?
|first       = Linus
|last        = Torvalds
|authorlink  = Linus Torvalds
|mailinglist = linux-kernel
|date        = 2007-10-25
|accessdate  = 2011-12-03
}}&lt;/ref&gt;}}
{{quotation|Some people think we hate GNU code. But the thing is we hate large code, and buggy code that upstream does not maintain. Thatâs the real problemâ¦ gcc gets about 5-6% slower every release, has new bugs, generates crappy code, and drives us nuts.|[[Theo de Raadt]]&lt;ref&gt;{{citation
|url        = http://www.thejemreport.com/more-on-openbsds-new-compiler/
|title      = More on OpenBSDâs new compiler
|work       = The Jem Report
|date       = 2007-10-15
|accessdate = 2011-12-03
}}&lt;/ref&gt;}}

==References==
{{Reflist|colwidth=30em}}

==See also==
{{Portal|Free software}}
* [[MinGW]] (Windows port of GCC)
* [[List of compilers]]

==Further reading==
{{Refbegin}}
* [[Richard Stallman]]: ''[http://gcc.gnu.org/onlinedocs/gcc-4.4.2/gcc/ Using the GNU Compiler Collection (GCC)]'', [[Free Software Foundation]], 2008.
* [[Richard Stallman]]: ''[http://gcc.gnu.org/onlinedocs/gccint/ GNU Compiler Collection (GCC) Internals]'', [[Free Software Foundation]], 2008.
* [[Brian J. Gough]]: ''[http://www.network-theory.co.uk/gcc/intro/ An Introduction to GCC]'', Network Theory Ltd., 2004 (Revised August 2005). ISBN 0-9541617-9-3.
* Arthur Griffith, ''GCC: The Complete Reference''. McGrawHill/Osborne, 2002. ISBN 0-07-222405-3.
{{Refend}}

==External links==
{{Wikibooks|GNU C Compiler Internals}}
* [http://gcc.gnu.org/ GCC homepage]
* [http://gcc.gnu.org/onlinedocs/ The official GCC manuals and user documentation], by the GCC developers
* [http://www.cse.iitb.ac.in/grc/index.php?page=docs Collection of GCC 4.0.2 architecture and internals documents] at I.I.T. Bombay.
* {{cite news|date=2006-03-02|title=New GCC Heavy on Optimization|publisher= internetnews.com | last= Kerner|first=Sean Michael | url = http://www.internetnews.com/dev-news/article.php/3588926 }}
* {{cite news|date=2005-04-22|title=Open Source GCC 4.0: Older, Faster|publisher= internetnews.com | last= Kerner|first=Sean Michael | url = http://www.internetnews.com/dev-news/article.php/3499881 }}
* [http://www.redhat.com/magazine/002dec04/features/gcc/ From Source to Binary: The Inner Workings of GCC], by Diego Novillo, [[Red Hat#Red Hat Magazine|''Red Hat Magazine'']], December 2004
* [ftp://gcc.gnu.org/pub/gcc/summit/2003/GENERIC%20and%20GIMPLE.pdf A 2003 paper on GENERIC and GIMPLE]
* [http://www.toad.com/gnu/cygnus/index.html Marketing Cygnus Support], an essay covering GCC development for the 1990s, with 30 monthly reports for in the &quot;Inside Cygnus Engineering&quot; section near the end.
* [http://www.goof.com/pcg/egcs.html EGCS 1.0 announcement]
* [http://gcc.gnu.org/egcs-1.0/features.html EGCS 1.0 features list]
* [http://linuxmafia.com/faq/Licensing_and_Law/forking.html Fear of Forking], an essay by Rick Moen recording seven well-known forks, including the GCC/EGCS one
* [http://www.cs.rochester.edu/twiki/bin/view/Main/ProjectHome A compiler course project] based on GCC at the [[University of Rochester]]
* [http://www.trl.ibm.com/projects/security/ssp/ The stack-smashing protector], a GCC extension

{{GNU}}
{{FOSS}}

&lt;!--Categories--&gt;
{{DEFAULTSORT:Gnu Compiler Collection}}
[[Category:1987 software]]
[[Category:C compilers]]
[[Category:C++ compilers]]
[[Category:Compilers]]
[[Category:Fortran compilers]]
[[Category:Free compilers and interpreters]]
[[Category:Free cross-platform software]]
[[Category:GNU Project software|Compiler Collection]]
[[Category:Java development tools]]
[[Category:Pascal compilers]]
[[Category:Unix programming tools]]

&lt;!--Interwikies--&gt;
[[ar:ØªØ¬ÙÙØ¹Ø© ÙØµØ±ÙØ§Øª Ø¬ÙÙ]]
[[bs:GNU Compiler Collection]]
[[bg:GNU Compiler Collection]]
[[ca:GNU Compiler Collection]]
[[cv:GNU Compiler Collection]]
[[cs:GCC]]
[[da:GCC]]
[[de:GNU Compiler Collection]]
[[et:GNU Compiler Collection]]
[[es:GNU Compiler Collection]]
[[eo:GCC]]
[[eu:GNU Compiler Collection]]
[[fa:Ø¬ÛâØ³ÛâØ³Û]]
[[fr:GNU Compiler Collection]]
[[gl:GNU Compiler Collection]]
[[ko:GNU ì»´íì¼ë¬ ëª¨ì]]
[[hy:GCC]]
[[hr:GNU Compiler Collection]]
[[it:GNU Compiler Collection]]
[[he:GCC]]
[[ka:GNU Compiler Collection]]
[[la:GCC]]
[[lt:GCC]]
[[hu:GCC (informatika)]]
[[ml:à´àµà´¨àµ à´à´®àµà´ªàµà´²àµ¼ à´¶àµà´à´°à´]]
[[nl:GNU Compiler Collection]]
[[ja:GNUã³ã³ãã¤ã©ã³ã¬ã¯ã·ã§ã³]]
[[no:GCC]]
[[pl:GNU Compiler Collection]]
[[pt:GNU Compiler Collection]]
[[ro:GNU Compiler Collection]]
[[ru:GNU Compiler Collection]]
[[sk:GNU Compiler Collection]]
[[sl:GNU Compiler Collection]]
[[sr:ÐÐÐ£ ÐºÐ¾Ð»ÐµÐºÑÐ¸ÑÐ° ÐºÐ¾Ð¼Ð¿Ð°ÑÐ»ÐµÑÐ°]]
[[fi:GCC]]
[[sv:GCC]]
[[th:à¸à¸¸à¸à¹à¸à¸¥à¹à¸à¸£à¹à¸à¸£à¸¡à¸à¸­à¸à¸à¸à¸¹]]
[[te:à°à±à°¨à± à°à°à°ªà±à°²à°°à± à°à°²à±à°à±à°·à°¨à±]]
[[tr:GNU Compiler Collection]]
[[uk:GNU Compiler Collection]]
[[vi:Bá» trÃ¬nh dá»ch GNU]]
[[zh:GCC]]</rev></revisions></page></pages></query></api>
