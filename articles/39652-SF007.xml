<?xml version="1.0"?><api><query><pages><page pageid="39652" ns="0" title="OCaml"><revisions><rev xml:space="preserve">{{Infobox programming language
 | name                   = OCaml
 | logo                   = 
 | logo caption           = 
 | screenshot             = 
 | screenshot caption     = 
 | file ext               = 
 | paradigm               = [[multi-paradigm programming language|multi-paradigm]]: [[imperative programming|imperative]], [[functional programming|functional]], [[object-oriented programming|object-oriented]]
 | scope                  =
 | released               = {{Start date|1996}}
 | designer               = 
 | developer              = [[INRIA]]
 | latest release version = 3.12.1
 | latest release date    = {{start date and age|2011|07|04}}
 | latest preview version = 
 | latest preview date    = &lt;!-- {{start date and age|YYYY|MM|DD}} --&gt;
 | typing                 = [[static typing|static]], [[strong typing|strong]], [[type inference|inferred]]
 | implementations        = 
 | dialects               = [[F Sharp programming language|F#]], [[JoCaml]], MetaOCaml, OcamlP3l
 | influenced by          = [[Caml Light]], [[Standard ML]]
 | influenced             = [[F Sharp (programming language)|F#]], [[Scala (programming language)|Scala]], [[ATS (programming language)|ATS]], [[Opa (programming language)|Opa]]
 | programming language   = [[Programming language]]
 | platform               = 
 | operating system       = [[Cross-platform]]
 | license                = [[Q Public License]] (compiler)&lt;br&gt;[[LGPL]] (library)
 | website                = {{url|http://caml.inria.fr/index.en.html}}
 | wikibooks              = Objective Caml
}}
'''OCaml''' ({{IPAc-en|icon|oÊ|Ë|k|Ã¦|m|Él}} {{respell|oh|KAM|Él}}), originally known as '''Objective Caml''', is the main implementation of the [[Caml]] [[programming language]], created by [[Xavier Leroy]], [[JÃ©rÃ´me Vouillon]], [[Damien Doligez]], [[Didier RÃ©my]] and others in 1996. OCaml extends the core Caml language with [[object-oriented programming|object-oriented]] constructs.

OCaml's toolset includes an interactive toplevel [[Interpreter (computing)|interpreter]], a [[bytecode]] [[compiler]], and an optimizing [[native code]] compiler. It has a large standard library that makes it useful for many of the same applications as [[Python (programming language)|Python]] or [[Perl]], as well as robust modular and object-oriented programming constructs that make it applicable for large-scale software engineering. OCaml is the successor to [[Caml Light]]. The acronym CAML originally stood for ''Categorical Abstract Machine Language'', although OCaml abandons this abstract machine.

OCaml is a [[free software|free]] [[open source software|open source]] project managed and principally maintained by [[Institut National de Recherche en Informatique et en Automatique|INRIA]]. In recent years, many new languages have drawn elements from OCaml, most notably [[F Sharp (programming language)|F#]] and [[Scala (programming language)|Scala]].

==Philosophy==
[[ML (programming language)|ML]]-derived languages are best known for their static [[type system]]s and [[type inference|type-inferring]] compilers. OCaml unifies [[functional programming|functional]], [[imperative programming|imperative]], and [[object-oriented programming]] under an ML-like type system. This means the program author is not required to be overly familiar with pure functional language paradigm in order to use OCaml.

OCaml's static type system can help eliminate problems at runtime. However, it also forces the programmer to conform to the constraints of the type system, which can require careful thought and close attention. A type-inferring compiler greatly reduces the need for manual type annotations (for example, the [[data type]] of variables and the signature of functions usually do not need to be explicitly declared, as they do in [[Java (programming language)|Java]]). Nonetheless, effective use of OCaml's type system can require some sophistication on the part of the programmer.

OCaml is perhaps most distinguished from other languages with origins in academia by its emphasis on performance. Firstly, its static type system renders runtime type mismatches impossible, and thus obviates runtime type and safety checks that burden the performance of dynamically typed languages, while still guaranteeing runtime safety (except when array bounds checking is turned off, or when certain type-unsafe features like serialization are used; these are rare enough that avoiding them is quite possible in practice).

Aside from type-checking overhead, [[functional programming]] languages are, in general, challenging to compile to efficient machine language code, due to issues such as the [[funarg problem]]. In addition to standard loop, register, and instruction [[compiler optimization|optimizations]], OCaml's optimizing compiler employs [[static program analysis]] techniques to optimize value [[Boxing (computer science)|boxing]] and [[Closure (computer science)|closure]] allocation, helping to maximize the performance of the resulting code even if it makes extensive use of functional programming constructs.

[[Xavier Leroy]] has stated that &quot;OCaml delivers at least 50% of the performance of a decent C compiler&quot;,&lt;ref name = &quot;LWN&quot;&gt;[http://lwn.net/Articles/19378/  Linux Weekly News].&lt;/ref&gt; but a direct comparison is impossible. Some functions in the OCaml standard library are implemented with faster algorithms than equivalent functions in the standard libraries of other languages. For example, the implementation of set union in the OCaml standard library is asymptotically faster than the equivalent function in the standard libraries of imperative languages (e.g. C++, Java) because the OCaml implementation exploits the immutability of sets in order to reuse parts of input sets in the output ([[Persistent data structure|persistence]]).

==Features==
OCaml features: a [[Semantic analysis (computer science)|static]]
[[type system]], [[type inference]],
[[polymorphism (computer science)|parametric polymorphism]], [[tail recursion]],
[[pattern matching]],
[[Closure (computer science)|first class lexical closures]],
[[Function object#Other meanings|functors (parametric modules)]], [[exception handling]], and
incremental generational [[garbage collection (computer science)|automatic garbage collection]].

OCaml is particularly notable for extending ML-style type inference to an object system in a general purpose language. This permits [[structural subtyping]], where object types are compatible, if their method signatures are compatible, regardless of their declared inheritance; an unusual feature in statically-typed languages.

A [[foreign function interface]] for [[Linker (computing)|linking]] to [[C (programming language)|C]] primitives is provided, including language support for efficient numerical [[Array data structure|arrays]] in formats compatible with both C and [[FORTRAN]]. OCaml also supports the creation of libraries of OCaml functions that can be linked to a &quot;main&quot; program in C, so that one could distribute an OCaml library to C programmers who have no knowledge nor installation of OCaml.

The OCaml distribution contains:
*An extensible parser and [[Macro (computer science)|macro language]] named [[Camlp4]], which permits the syntax of OCaml to be extended or even replaced
*Lexer and parser tools called ocamllex and ocamlyacc
* [[Debugger]] that supports stepping backwards to investigate errors
* [[Documentation generator]]
* [[Profiler (computer science)|Profiler]] â for measuring performance
*Numerous general purpose [[library (computer science)|libraries]]

The native code compiler is available for many platforms, including [[Unix]], [[Microsoft Windows]], and [[Apple Computer|Apple]] [[Mac OS X]]. Excellent portability is ensured through native code generation support for major architectures: [[IA-32]], [[Itanium|IA-64]], [[X86-64|AMD64]], [[PA-RISC family|HP/PA]]; [[PowerPC]], [[SPARC]], [[DEC Alpha|Alpha]], [[MIPS architecture|MIPS]], and [[StrongARM]].

OCaml bytecode and native code programs can be written in a [[Thread (computer science)|multithreaded]] style, with preemptive context switching. However, because the garbage collector is not designed for concurrency, [[symmetric multiprocessing]] is not supported.&lt;ref name = &quot;INRIA&quot;&gt;[http://caml.inria.fr/pub/ml-archives/caml-list/2002/11/64c14acb90cb14bedb2cacb73338fb15.en.html Xavier Leroy's &quot;standard lecture&quot; on threads]&lt;/ref&gt; OCaml threads in the same process execute by time sharing only. There are however several libraries for distributed computing such as [http://www.lri.fr/~filliatr/functory/About.html Functory] and [http://projects.camlcity.org/projects/ocamlnet.html ocamlnet]/[http://plasma.camlcity.org/plasma/index.html Plasma] ([http://blog.camlcity.org/blog/plasma3.html blog]).

==Code examples==
Snippets of OCaml code are most easily studied by entering them into the &quot;top-level&quot;. This is an interactive OCaml session that prints the inferred types of resulting or defined expressions. The OCaml top-level is started by simply executing the OCaml program:

   $ ocaml
        Objective Caml version 3.09.0
 
   #

Code can then be entered at the &quot;#&quot; prompt. For example, to calculate 1+2*3:

   # 1 + 2 * 3;;
   - : int = 7

OCaml infers the type of the expression to be &quot;int&quot; (a machine-precision integer) and gives the result &quot;7&quot;.

===Hello World===
The following program &quot;hello.ml&quot;:

&lt;source lang=OCaml&gt;
 print_endline &quot;Hello World!&quot;
&lt;/source&gt;

can be compiled into a bytecode executable:

 $ ocamlc hello.ml -o hello

or compiled into an optimized native-code executable:

 $ ocamlopt hello.ml -o hello

and executed:

 $ ./hello
 Hello World!
 $

===Summing a list of integers===

Lists are one of the most fundamental datatypes in OCaml. The following code example defines a ''recursive'' function ''sum'' that accepts one argument ''xs''. The function recursively iterates over a given list and provides a sum of integer elements. The ''match'' statement has similarities with [[C++]] or [[Java (programming language)|Java]] languages' [[Switch statement|switch]] element, though it is much more general.

&lt;source lang=OCaml&gt;
let rec sum xs =
  match xs with
    [] -&gt; 0
    | x :: xs' -&gt; x + sum xs'
&lt;/source&gt;

  # sum [1;2;3;4;5];;
  - : int = 15

Another way is to use standard [[fold function]] that works with lists.

&lt;source lang=OCaml&gt;
let sum xs =
    List.fold_left (+) 0 xs
&lt;/source&gt;

  # sum [1;2;3;4;5];;
  - : int = 15

=== Quicksort ===
OCaml lends itself to the concise expression of recursive algorithms. The following code example implements an algorithm similar to [[quicksort]] that sorts a list in increasing order.

&lt;source lang=OCaml&gt;
 let rec qsort = function
   | [] -&gt; []
   | pivot :: rest -&gt;
       let is_less x = x &lt; pivot in
       let left, right = List.partition is_less rest in
       qsort left @ [pivot] @ qsort right
&lt;/source&gt;

===Birthday paradox===
The following program calculates the smallest number of people in a room for whom the probability of completely unique birthdays is less than 50% (the so-called [[birthday paradox]], where for 1 person the probability is obviously 100%, for 2 it is 364/365, etc.) (answer = 23).

&lt;source lang=OCaml&gt;
 let year_size = 365.
 
 let rec birthday_paradox prob people =
     let prob' = (year_size -. float people) /. year_size *. prob  in
     if prob' &lt; 0.5 then
         Printf.printf &quot;answer = %d\n&quot; (people+1)
     else
         birthday_paradox prob' (people+1) ;;
 
 birthday_paradox 1.0 1
&lt;/source&gt;

===Church numerals===
The following code defines a [[Church encoding]] of natural numbers, with successor (succ) and addition (add). A Church numeral {{OCaml|n}} is a higher-order function that accepts a function {{OCaml|f}} and a value {{OCaml|x}} and applies {{OCaml|f}} to {{OCaml|x}} exactly {{OCaml|n}} times. To convert a Church numeral from a functional value to a string, we pass it a function that prepends the string {{OCaml|&quot;S&quot;}} to its input and the constant string {{OCaml|&quot;0&quot;}}.

&lt;source lang=OCaml&gt;
let zero f x = x
let succ n f x = f (n f x)
let one = succ zero
let two = succ (succ zero)
let add n1 n2 f x = n1 f (n2 f x)
let to_string n = n (fun k -&gt; &quot;S&quot; ^ k) &quot;0&quot;
let _ = to_string (add (succ two) two)
&lt;/source&gt;

===Arbitrary-precision factorial function (libraries)===
A variety of libraries are directly accessible from OCaml. For example, OCaml has a built-in library for arbitrary precision arithmetic. As the factorial function grows very rapidly, it quickly overflows machine-precision numbers (typically 32- or 64-bits). Thus, factorial is a suitable candidate for arbitrary-precision arithmetic.

In OCaml, the Num module provides arbitrary-precision arithmetic and can be loaded into a running top-level using:

&lt;source lang=OCaml&gt;
# #load &quot;nums.cma&quot;;;
# open Num;;
&lt;/source&gt;

The factorial function may then be written using the arbitrary-precision numeric operators =/, */ and -/ :

&lt;source lang=OCaml&gt;
# let rec fact n =
    if n =/ Int 0 then Int 1 else n */ fact(n -/ Int 1);;
val fact : Num.num -&gt; Num.num = &lt;fun&gt;
&lt;/source&gt;

This function can compute much larger factorials, such as 120!:

&lt;source lang=OCaml&gt;
# string_of_num (fact (Int 120));;
- : string =
&quot;6689502913449127057588118054090372586752746333138029810295671352301633
55724496298936687416527198498130815763789321409055253440858940812185989
8481114389650005964960521256960000000000000000000000000000&quot;
&lt;/source&gt;

The cumbersome syntax for Num operations can be alleviated thanks to the camlp4 syntax extension called [http://pa-do.forge.ocamlcore.org/ Delimited overloading]: 

&lt;source lang=OCaml&gt;
# #require &quot;pa_do.num&quot;;;
# let rec fact n = Num.(if n = 0 then 1 else n * fact(n-1));;
val fact : Num.num -&gt; Num.num = &lt;fun&gt;
# fact Num.(120);;
- : Num.num =
  &lt;num 668950291344912705758811805409037258675274633313802981029567
  135230163355724496298936687416527198498130815763789321409055253440
  8589408121859898481114389650005964960521256960000000000000000000000000000&gt;
&lt;/source&gt;

===Triangle (graphics)===
The following program &quot;simple.ml&quot; renders a rotating triangle in 2D using [[OpenGL]]:

&lt;source lang=OCaml&gt;
 let () =
   ignore( Glut.init Sys.argv );
   Glut.initDisplayMode ~double_buffer:true ();
   ignore (Glut.createWindow ~title:&quot;OpenGL Demo&quot;);
   let angle t = 10. *. t *. t in
   let render () =
     GlClear.clear [ `color ];
     GlMat.load_identity ();
     GlMat.rotate ~angle: (angle (Sys.time ())) ~z:1. ();
     GlDraw.begins `triangles;
     List.iter GlDraw.vertex2 [-1., -1.; 0., 1.; 1., -1.];
     GlDraw.ends ();
     Glut.swapBuffers () in
   GlMat.mode `modelview;
   Glut.displayFunc ~cb:render;
   Glut.idleFunc ~cb:(Some Glut.postRedisplay);
   Glut.mainLoop ()
&lt;/source&gt;

The LablGL bindings to OpenGL are required. The program may then be compiled to bytecode with:

   $ ocamlc -I +lablGL lablglut.cma lablgl.cma simple.ml -o simple

or to nativecode with:

   $ ocamlopt -I +lablGL lablglut.cmxa lablgl.cmxa simple.ml -o simple

and run:

   $ ./simple

Far more sophisticated, high-performance 2D and 3D graphical programs are easily developed in OCaml. Thanks to the use of OpenGL, the resulting programs are not only succinct and efficient, but also cross-platform, compiling without any changes on all major platforms.

=== Fibonacci Sequence ===
The following code calculates the Fibonacci sequence of a number ''n'' inputed. It uses [[tail recursion]] and pattern matching.
&lt;source lang = OCaml&gt;
let rec fib_aux n a b =
  match n with
  | 0 -&gt; a
  | _ -&gt; fib_aux (n - 1) (a + b) a
let fib n = fib_aux n 0 1
&lt;/source&gt;

==Derived languages==
===MetaOCaml===
MetaOCaml&lt;ref name = &quot;Meta&quot;&gt;[http://www.metaocaml.org/  MetaOCaml]&lt;/ref&gt; is a [[multi-stage programming]] extension of OCaml enabling incremental compiling of new machine code during runtime. Under certain circumstances, significant speedups are possible using multi-stage programming, because more detailed information about the data to process is available at runtime than at the regular compile time, so the incremental compiler can optimize away many cases of condition checking etc.

As an example: if at compile time it is known that a certain [[Exponentiation|power function]] {{OCaml|x -&gt; x^n}} is needed very frequently, but the value of {{OCaml|n}} is known only at runtime, you can use a two-stage power function in MetaOCaml:

&lt;source lang=OCaml&gt;
 let rec power n x =
   if n = 0
   then .&lt;1&gt;.
   else
     if even n
     then sqr (power (n/2) x)
     else .&lt;.~x *. ~(power (n-1) x)&gt;.
&lt;/source&gt;

As soon as you know {{OCaml|n}} at runtime, you can create a specialized and very fast power function:

&lt;source lang=OCaml&gt;
 .&lt;fun x -&gt; .~(power 5 .&lt;x&gt;.)&gt;.
&lt;/source&gt;

The result is:

&lt;source lang=OCaml&gt;
 fun x_1 -&gt; (x_1 *
     let y_3 = 
         let y_2 = (x_1 * 1)
         in (y_2 * y_2)
     in (y_3 * y_3))
&lt;/source&gt;

The new function is automatically compiled.

===Other derived languages===
* [http://www.cs.washington.edu/homes/miker/atomcaml/ AtomCaml] provides a synchronization primitive for atomic (transactional) execution of code.
*&quot;[http://wiki.erights.org/wiki/Emily Emily] is a subset of OCaml that uses a design rule verifier to enforce [[Object-capability model|object-capability]] &lt;nowiki&gt;[&lt;/nowiki&gt;[[Capability-based security|security]]&lt;nowiki&gt;]&lt;/nowiki&gt; principles.&quot;
* [[F Sharp (programming language)|F#]] is a [[Microsoft .NET]] language based on OCaml.
* [http://www.fresh-ocaml.org/ Fresh OCaml] facilitates the manipulation of names and binders.
* [http://www.yl.is.s.u-tokyo.ac.jp/~furuse/gcaml/ GCaml] adds extensional polymorphism to OCaml, thus allowing overloading and type-safe marshalling.
* [[JoCaml]] integrates constructions for developing concurrent and distributed programs.
* [http://www.cduce.org/ocaml OCamlDuce] extends OCaml with features such as XML expressions and regular-expression types.
* [http://www.pps.jussieu.fr/~dicosmo/ocamlp3l/index.html OCamlP3l] is a [[parallel programming]] system based on OCaml and the P3L language

==Software written in OCaml ==

* [[FFTW]] &amp;ndash; a software library for computing [[discrete Fourier transform]]s. Several C routines have been generated by an OCaml program named {{OCaml|genfft}}.
* [[Unison (file synchronizer)|Unison]] &amp;ndash; a [[file synchronization]] program to synchronize files between two directories.
* [http://galax.sourceforge.net/about.html Galax] &amp;ndash; an open source [[XQuery]] implementation.
* [[Mldonkey]] &amp;ndash; a peer to peer client based on the [[EDonkey network]].
* [[GeneWeb]] &amp;ndash; free open source multi-platform genealogy software.
* [[haXe#Compiler implementation and performance|The haXe compiler]] &amp;ndash; a free open source compiler for the [[haXe]] programming language.
* [[Frama-c]] &amp;ndash; a framework for [[C program]]s analysis.
* [[Liquidsoap]] &amp;ndash; Liquidsoap is the audio stream generator of the [[Savonet]] project, notably used for generating the stream of netradios. [http://savonet.sourceforge.net/]
* [[Coccinelle (software)|Coccinelle]] &amp;ndash; Coccinelle is a program matching and transformation engine that provides the SmPL language  (Semantic Patch Language) for specifying desired matches and transformations in [[C (programming language)|C]] code. [http://coccinelle.lip6.fr/]
* [[CSIsat]] &amp;ndash; a Tool for LA+EUF Interpolation.
* [[Orpie]] &amp;ndash; a command-line [[reverse polish notation|RPN]] calculator
* [[Coq]] &amp;ndash; a formal proof management system.
* [[Ocsigen]] &amp;ndash; web development framework
* [http://www.openmirage.org/ Mirage] &amp;ndash; operating system for constructing secure, high-performance, reliable network applications across a variety of cloud computing and mobile platforms
* [[Opa (programming language)|Opa]] &amp;ndash; an open source programming language for web development.

The private trading firm Jane Street Capital has adopted OCaml as its preferred language. [http://cacm.acm.org/magazines/2011/11/138203-ocaml-for-the-masses/fulltext]

==See also==
* [[Caml]] and [[Caml Light]], languages from which OCaml evolved
* [[Standard ML]], another popular dialect of ML
* [[Extensible ML]], another object-oriented dialect of ML
* [[O'Haskell]], an object-oriented extension to the functional language [[Haskell (programming language)|Haskell]]

==References==
{{reflist}}

==External links ==
{{wikibooks|Objective Caml}}
* [http://caml.inria.fr/ Caml language family official website] 
** [http://caml.inria.fr/humps/caml_latest.html OCaml libraries]
* [http://mirror.ocamlcore.org/ocaml-tutorial.org/ OCaml tutorial for C, C++, Java and Perl programmers]
* [http://files.metaprl.org/doc/ocaml-book.pdf Jason Hickey book]
* [http://www.ocf.berkeley.edu/~mbh/tutorial/index.html A basic OCaml tutorial]
* [http://www.soton.ac.uk/~fangohr/software/ocamltutorial/index.html A Tutorial with a practical approach.]
* [http://planet.ocamlcore.org/ OCamlcore Planet] aggregation of people and institutional feeds about OCaml.
* [http://forge.ocamlcore.org/ OCamlForge] a free service to Open Source OCaml developers offering easy access to the best in source control management, mailing lists, bug tracking, message boards/forums, task management, site hosting, permanent file archival, full backups, and total web-based administration.
* [http://batteries.forge.ocamlcore.org OCaml Batteries Included], a community-built standard library for OCaml
* [http://ocamljava.x9c.fr/ OCaml-Java], OCaml for Java
* [http://www.pps.jussieu.fr/~montela/ocamil/ OCamIL], an OCaml compiler for [[.NET Framework|Microsoft .NET]]
* [http://wwwfun.kurims.kyoto-u.ac.jp/soft/olabl/lablgtk.html LablGL and LablGTK] [[OpenGL]]+ bindings (LablGL) and [[GTK+]] bindings (LablGTK)
* [http://sourceforge.net/softwaremap/trove_list.php?stquery=&amp;sort=registration_date&amp;sortdir=desc&amp;offset=0&amp;form_cat=454 Newest OCaml Projects on Sourceforge]
* [http://shootout.alioth.debian.org/ Comparison of the speed of various languages] including OCaml
* [http://www.metaocaml.org MetaOCaml] home page
*the [http://godi.camlcity.org/godi/index.html GODI] package manager for OCaml
* [http://ocamlwizard.lri.fr Ocamlwizard]

&lt;!--Categories--&gt;
[[Category:ML programming language family]]
[[Category:Functional languages]]
[[Category:Object-oriented programming languages]]
[[Category:Extensible syntax programming languages]]
[[Category:Free cross-platform software]]
[[Category:Free compilers and interpreters]]
[[Category:OCaml software]]
[[Category:Programming languages created in 1996]]

&lt;!--Interwikis--&gt;

[[ar:ÙØºØ© ÙØ§ÙÙ Ø§ÙÙÙØ¶ÙØ¹ÙØ©]]
[[ca:OCaml]]
[[cs:OCaml]]
[[de:Objective CAML]]
[[el:OCaml]]
[[es:Ocaml]]
[[fr:OCaml]]
[[gl:Ocaml]]
[[ko:Objective Caml]]
[[it:Objective Caml]]
[[ka:ááááá¥á¢á£á á ááááá]]
[[la:Ocaml]]
[[ms:OCaml]]
[[nl:Ocaml]]
[[ja:OCaml]]
[[no:Objective Caml]]
[[nn:OCaml]]
[[pl:OCaml]]
[[pt:OCaml]]
[[ru:OCaml]]
[[simple:OCaml]]
[[sl:Ocaml]]
[[fi:Objective Caml]]
[[tg:OCaml]]
[[tr:OCaml]]
[[uk:Objective Caml]]
[[vi:OCaml]]
[[zh:OCaml]]</rev></revisions></page></pages></query></api>
